/*
 * Copyright (c) 2017 Giulio Bernardi (https://github.com/ugilio/).
 * All rights reserved.   This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * generated by Xtext 2.12.0
 */
package com.github.ugilio.ghost.tests

import com.github.ugilio.ghost.ghost.CompDecl
import com.github.ugilio.ghost.ghost.Ghost
import com.github.ugilio.ghost.ghost.QualifInstVal
import com.github.ugilio.ghost.ghost.SyncBody
import com.github.ugilio.ghost.ghost.TransConstraint
import com.github.ugilio.ghost.ghost.TriggerType
import com.github.ugilio.ghost.ghost.TypeDecl
import com.github.ugilio.ghost.preprocessor.AnnotationProvider.AnnotationProviderException
import com.github.ugilio.ghost.services.GhostGrammarAccess
import com.google.common.collect.Sets
import com.google.inject.Inject
import java.util.Set
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.TerminalRule
import org.eclipse.xtext.nodemodel.util.NodeModelUtils
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.XtextRunner
import org.eclipse.xtext.testing.util.ParseHelper
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith

import static org.hamcrest.CoreMatchers.*
import static org.junit.Assert.*
import com.github.ugilio.ghost.ghost.LocVarDecl
import com.github.ugilio.ghost.preprocessor.AnnotationProvider

@RunWith(XtextRunner)
@InjectWith(GhostInjectorProvider)
class GhostAnnotationProviderTest{
	
	@Inject ParseHelper<Ghost> parseHelper;
	
	@Inject
	GhostGrammarAccess ga;

	@Inject
	AnnotationProvider p;
	
	Resource r;
	
	Set<TerminalRule> annRules;

	@Before
	def void setUp() {
		annRules = Sets.newHashSet(ga.SL_ANNOTATIONRule,ga.BR_ANNOTATIONRule);
	}
	
	def EObject parse(CharSequence text) {
		val model = parseHelper.parse(text);
		r = model.eResource;
		return model;
	}
	
	private def getAllAnnotationNodes(EObject model) {
		val root = NodeModelUtils.getNode(model);
		root.asTreeIterable.
			filter[annRules.contains(grammarElement)].
			toList;
	}
	
	private def getFirstAnnotationNode(EObject model) {
		return getAllAnnotationNodes(model).head;
	}
	
	@Test
	def void testSimple1() {
		val model = '''
			@ann
			comp c : sv;
		'''.parse;
		val node = model.firstAnnotationNode;
		p.addAnnotation(node);
		val c = EcoreUtil2.eAllOfType(model,CompDecl).head;
		val l = p.getAnnotations(c);
		assertThat(l,is(notNullValue));
		assertThat(l.size(),is(1));
		assertThat(l.head,is(equalTo("ann")));
	}
	
	@Test
	def void testSimple2() {
		val model = '''
			@(ann) comp c : sv;
		'''.parse;
		val node = model.firstAnnotationNode;
		p.addAnnotation(node);
		val c = EcoreUtil2.eAllOfType(model,CompDecl).head;
		val l = p.getAnnotations(c);
		assertThat(l,is(notNullValue));
		assertThat(l.size(),is(1));
		assertThat(l.head,is(equalTo("ann")));
	}
	
	@Test
	def void testMulti1() {
		val model = '''
			@a lot of things
			comp c : sv;
		'''.parse;
		val node = model.firstAnnotationNode;
		p.addAnnotation(node);
		val c = EcoreUtil2.eAllOfType(model,CompDecl).head;
		val l = p.getAnnotations(c);
		assertThat(l,is(notNullValue));
		assertThat(l.size(),is(1));
		assertThat(l.head,is(equalTo("a lot of things")));
	}
	
	@Test
	def void testMulti2() {
		val model = '''
			@(a lot of things)
			comp c : sv;
		'''.parse;
		val node = model.firstAnnotationNode;
		p.addAnnotation(node);
		val c = EcoreUtil2.eAllOfType(model,CompDecl).head;
		val l = p.getAnnotations(c);
		assertThat(l,is(notNullValue));
		assertThat(l.size(),is(1));
		assertThat(l.head,is(equalTo("a lot of things")));
	}
	
	@Test
	def void testMulti3() {
		val model = '''
			@(a) @(lot) @(of) @(things)
			comp c : sv;
		'''.parse;
		val nodes = model.allAnnotationNodes;
		for (n : nodes)
			p.addAnnotation(n);
		val c = EcoreUtil2.eAllOfType(model,CompDecl).head;
		val l = p.getAnnotations(c);
		assertThat(l,is(notNullValue));
		assertThat(l.size(),is(4));
		assertThat(l.toString,is(equalTo("[a, lot, of, things]")));
	}
	
	@Test(expected = AnnotationProviderException)
	def void testNoElements1() {
		val model = '''
			@(ann)
		'''.parse;
		val node = model.firstAnnotationNode;
		p.addAnnotation(node);
	}
	
	@Test(expected = AnnotationProviderException)
	def void testNoElements2() {
		val model = '''
		type t = sv (
			@(ann)
		);
		comp c : t;
		'''.parse;
		val node = model.firstAnnotationNode;
		p.addAnnotation(node);
	}
	
	@Test
	def void testCommentBetween() {
		val model = '''
			@ann
			//We don't care about comments
			comp c : sv;
		'''.parse;
		val node = model.firstAnnotationNode;
		p.addAnnotation(node);
		val c = EcoreUtil2.eAllOfType(model,CompDecl).head;
		val l = p.getAnnotations(c);
		assertThat(l,is(notNullValue));
		assertThat(l.size(),is(1));
		assertThat(l.head,is(equalTo("ann")));
	}
	
	@Test
	def void testPreprocBetween() {
		val model = '''
			@ann
			$and neither we care about preprocessor directives 
			comp c : sv;
		'''.parse;
		val node = model.firstAnnotationNode;
		p.addAnnotation(node);
		val c = EcoreUtil2.eAllOfType(model,CompDecl).head;
		val l = p.getAnnotations(c);
		assertThat(l,is(notNullValue));
		assertThat(l.size(),is(1));
		assertThat(l.head,is(equalTo("ann")));
	}
	
	@Test
	def void testType1() {
		val model = '''
			@ann
			type t = sv;
		'''.parse;
		val node = model.firstAnnotationNode;
		p.addAnnotation(node);
		val t = EcoreUtil2.eAllOfType(model,TypeDecl).head;
		val l = p.getAnnotations(t);
		assertThat(l,is(notNullValue));
		assertThat(l.size(),is(1));
		assertThat(l.head,is(equalTo("ann")));
	}
	
	@Test
	def void testType2() {
		val model = '''
			@ann
			external type t = sv;
		'''.parse;
		val node = model.firstAnnotationNode;
		p.addAnnotation(node);
		val t = EcoreUtil2.eAllOfType(model,TypeDecl).head;
		val l = p.getAnnotations(t);
		assertThat(l,is(notNullValue));
		assertThat(l.size(),is(1));
		assertThat(l.head,is(equalTo("ann")));
	}
	
	@Test
	def void testComp2() {
		val model = '''
			@ann
			external comp c : sv;
		'''.parse;
		val node = model.firstAnnotationNode;
		p.addAnnotation(node);
		val c = EcoreUtil2.eAllOfType(model,CompDecl).head;
		val l = p.getAnnotations(c);
		assertThat(l,is(notNullValue));
		assertThat(l.size(),is(1));
		assertThat(l.head,is(equalTo("ann")));
	}
	
	@Test
	def void testTcHead1() {
		val model = '''
			type t = sv(
				@(ann) A -> B, B
			);
		'''.parse;
		val node = model.firstAnnotationNode;
		p.addAnnotation(node);
		val tc = EcoreUtil2.eAllOfType(model,TransConstraint).head;
		val l = p.getAnnotations(tc);
		assertThat(l,is(notNullValue));
		assertThat(l.size(),is(1));
		assertThat(l.head,is(equalTo("ann")));
	}
	
	@Test
	def void testTcHead2() {
		val model = '''
			type t = sv(
				@(ann) contr A -> B, B
			);
		'''.parse;
		val node = model.firstAnnotationNode;
		p.addAnnotation(node);
		val tc = EcoreUtil2.eAllOfType(model,TransConstraint).head;
		val l = p.getAnnotations(tc);
		assertThat(l,is(notNullValue));
		assertThat(l.size(),is(1));
		assertThat(l.head,is(equalTo("ann")));
	}
	
	@Test
	def void testSyncTrigger1() {
		val model = '''
			type t = sv(
				A -> B;
			synchronize:
				@(ann) A -> 10 > 0;
			);
		'''.parse;
		val node = model.firstAnnotationNode;
		p.addAnnotation(node);
		val s = EcoreUtil2.eAllOfType(model,TriggerType).head;
		val l = p.getAnnotations(s);
		assertThat(l,is(notNullValue));
		assertThat(l.size(),is(1));
		assertThat(l.head,is(equalTo("ann")));
	}
	
	@Test
	def void testSyncTrigger2() {
		val model = '''
			type t = resource(10
			synchronize:
				@(ann) require(x) -> x > 0;
			);
		'''.parse;
		val node = model.firstAnnotationNode;
		p.addAnnotation(node);
		val s = EcoreUtil2.eAllOfType(model,TriggerType).head;
		val l = p.getAnnotations(s);
		assertThat(l,is(notNullValue));
		assertThat(l.size(),is(1));
		assertThat(l.head,is(equalTo("ann")));
	}
	
	@Test
	def void testIcd1() {
		val model = '''
			comp c : sv(
				A -> B, B;
			synchronize:
				A -> before @(ann) c.B;
			);
		'''.parse;
		val node = model.firstAnnotationNode;
		p.addAnnotation(node);
		val s = EcoreUtil2.eAllOfType(model,SyncBody).head;
		val icd = EcoreUtil2.eAllOfType(s,QualifInstVal).head;
		val l = p.getAnnotations(icd);
		assertThat(l,is(notNullValue));
		assertThat(l.size(),is(1));
		assertThat(l.head,is(equalTo("ann")));
	}
	
	@Test
	def void testIcd2() {
		val model = '''
			comp c : sv(
				A -> B, B;
			synchronize:
				A -> @(ann) before c.B;
			);
		'''.parse;
		val node = model.firstAnnotationNode;
		p.addAnnotation(node);
		val s = EcoreUtil2.eAllOfType(model,SyncBody).head;
		val icd = EcoreUtil2.eAllOfType(s,QualifInstVal).head;
		val l = p.getAnnotations(icd);
		assertThat(l,is(notNullValue));
		assertThat(l.size(),is(1));
		assertThat(l.head,is(equalTo("ann")));
	}
	
	@Test
	def void testIcd2a() {
		val model = '''
			comp c : sv(
				A -> B, B
			synchronize:
				A -> @(ann) = c.B;
			);
		'''.parse;
		val node = model.firstAnnotationNode;
		p.addAnnotation(node);
		val s = EcoreUtil2.eAllOfType(model,SyncBody).head;
		val icd = EcoreUtil2.eAllOfType(s,QualifInstVal).head;
		val l = p.getAnnotations(icd);
		assertThat(l,is(notNullValue));
		assertThat(l.size(),is(1));
		assertThat(l.head,is(equalTo("ann")));
	}
	
	@Test
	def void testIcd3() {
		val model = '''
			comp c : sv(
				A -> B, B
			synchronize:
				A -> @(ann) c.A before c.B;
			);
		'''.parse;
		val node = model.firstAnnotationNode;
		p.addAnnotation(node);
		val s = EcoreUtil2.eAllOfType(model,SyncBody).head;
		val icd = EcoreUtil2.eAllOfType(s,QualifInstVal).head;
		val l = p.getAnnotations(icd);
		assertThat(l,is(notNullValue));
		assertThat(l.size(),is(1));
		assertThat(l.head,is(equalTo("ann")));
	}
	
	@Test
	def void testVar1() {
		val model = '''
			comp c : sv(
				A -> B, B;
			synchronize:
				A -> (
					@(ann) var cd1 = c.B;
					before cd1;
				);
			);
		'''.parse;
		val node = model.firstAnnotationNode;
		p.addAnnotation(node);
		val s = EcoreUtil2.eAllOfType(model,SyncBody).head;
		val cd1 = EcoreUtil2.eAllOfType(s,LocVarDecl).head;
		val l = p.getAnnotations(cd1);
		assertThat(l,is(notNullValue));
		assertThat(l.size(),is(1));
		assertThat(l.head,is(equalTo("ann")));
	}
	
	@Test
	def void testVar2() {
		val model = '''
			comp c : sv(
				A -> B, B;
			synchronize:
				A -> (
					var cd1 = @(ann) c.B;
					before cd1;
				);
			);
		'''.parse;
		val node = model.firstAnnotationNode;
		p.addAnnotation(node);
		val s = EcoreUtil2.eAllOfType(model,SyncBody).head;
		val icd = EcoreUtil2.eAllOfType(s,QualifInstVal).head;
		val l = p.getAnnotations(icd);
		assertThat(l,is(notNullValue));
		assertThat(l.size(),is(1));
		assertThat(l.head,is(equalTo("ann")));
	}
	
	@Test
	def void testVar3() {
		val model = '''
			comp c : sv(
				A -> B, B;
			synchronize:
				A -> (
					var cd1 = c.B;
					before @(ann) cd1;
				);
			);
		'''.parse;
		val node = model.firstAnnotationNode;
		p.addAnnotation(node);
		val s = EcoreUtil2.eAllOfType(model,SyncBody).head;
		val icd = EcoreUtil2.eAllOfType(s,QualifInstVal).get(1);
		val l = p.getAnnotations(icd);
		assertThat(l,is(notNullValue));
		assertThat(l.size(),is(1));
		assertThat(l.head,is(equalTo("ann")));
	}
	
}
