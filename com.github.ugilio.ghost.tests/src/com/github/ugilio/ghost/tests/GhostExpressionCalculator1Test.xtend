/*
 * Copyright (c) 2017 Giulio Bernardi (https://github.com/ugilio/).
 * All rights reserved.   This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * generated by Xtext 2.12.0
 */
package com.github.ugilio.ghost.tests

import com.google.inject.Inject
import com.github.ugilio.ghost.generator.internal.BlockAdapter
import com.github.ugilio.ghost.generator.internal.BlockImpl
import com.github.ugilio.ghost.generator.internal.ExpressionCalculator
import com.github.ugilio.ghost.generator.internal.ExpressionImpl
import com.github.ugilio.ghost.generator.internal.Register
import it.cnr.istc.timeline.lang.Variable
import java.util.Collections
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.XtextRunner
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith

import static org.hamcrest.CoreMatchers.*
import static org.junit.Assert.*
import com.github.ugilio.ghost.generator.internal.VariableProxy

@RunWith(XtextRunner)
@InjectWith(GhostInjectorProvider)
class GhostExpressionCalculator1Test{

	@Inject
	Register register;

	ExpressionCalculator c;
	BlockImpl b;
	
	Variable x = new VariableProxy("x",null); 
	
	BlockAdapter ba = new BlockAdapter(){
		
		override getContents() {
			return Collections.singletonList(x);
		}
		
		override getContainer() {
			return null;
		}
		
		override <T extends EObject> getContainerOfType(Class<T> clazz) {
			return null;
		}
		
	}

	@Before
	def void setup() {
		b = new BlockImpl(ba,null,register);
		c = new ExpressionCalculator(b);
	}

	def ExpressionImpl exp(Object ... data) {
		val e = new ExpressionImpl(null,register);
		e.operands.set(0,data.get(0));
		var i = 1; 
		while (i+1 < data.size()) {
			e.operators.add(data.get(i) as String);
			e.operands.add(data.get(i+1));
			i+=2;
		}
		return e;
	}
	
	private def int getOpDegree(String op) {
		return
		switch (op) {
			case '*', case '/', case '%': 1
			case '+', case '-': 2
			case '<', case '<=', case '>', case '>=' : 3
			case '=', case '!=' : 4
			default: 0
		}
	}
	
	private def getExpDegree(ExpressionImpl exp) {
		if (exp.operators.size()>0) return getOpDegree(exp.operators.get(0))
		return 0;
	}
	
	def dispatch String printExp(ExpressionImpl exp) {
		var str = "";
		for (var i = 0; i < exp.operands.size(); i++) {
			val sub = exp.operands.get(i);
			var subStr = printExp(sub);
			if (sub instanceof ExpressionImpl && exp.operators.size()>0) {
				val op = exp.operators.get(0);
				val needParens = getOpDegree(op) <= getExpDegree(sub as ExpressionImpl);
				if (needParens) subStr = "("+subStr+")";	
			}
			str+=subStr;
			if (i < exp.operators.size())
				str+= " "+exp.operators.get(i)+" ";
		}
		
		return str.trim();
	}

	def dispatch String printExp(Variable exp) {
		return exp.name;
	}
	
	def dispatch String printExp(Object exp) {
		return ""+exp;
	}
	
	def dispatch String printExp(Void exp) { "" }
	
	
	@Test
	def void testSingleValue() {
		//1
		val e = exp(1L);
		val r = c.evaluate(e);
		assertThat(r,is(1L));
	}
	
	@Test
	def void test1() {
		//1+2 = 3
		val e = exp(1L,"+",2L);
		val r = c.evaluate(e);
		assertThat(r,is(3L));
	}
	
	@Test
	def void test2() {
		//1+(2*7)+4 = 19
		val e = exp(1L,"+",exp(2L,"*",7L),"+",4L);
		val r = c.evaluate(e);
		assertThat(r,is(19L));
	}
	
	@Test
	def void test3() {
		//1-(2*7)+4 = -9
		val e = exp(1L,"-",exp(2L,"*",7L),"+",4L);
		val r = c.evaluate(e);
		assertThat(r,is(-9L));
	}
	
	@Test
	def void testVar1() {
		//x
		val e = exp(x);
		val r = c.evaluate(e);
		assertThat(r,is(x));
	}
	
	@Test
	def void testVar2() {
		//1+x
		val e = exp(1L,'+',x);
		val r = c.evaluate(e);
		assertThat(printExp(r),is(equalTo("1 + x")));
	}
	
	@Test
	def void testVar3() {
		//1+2*x
		val e = exp(1L,'+',exp(2L,"*",x));
		val r = c.evaluate(e);
		assertThat(printExp(r),is(equalTo("1 + 2 * x")));
	}
	
	@Test
	def void testVar4() {
		//2*(x+7)
		val e = exp(2L,'*',exp(x,"+",7L));
		val r = c.evaluate(e);
		assertThat(printExp(r),is(equalTo("2 * x + 14")));
	}
	
	@Test
	def void testVar4b() {
		//(x+7)*2
		val e = exp(exp(x,"+",7L),'*',2L);
		val r = c.evaluate(e);
		assertThat(printExp(r),is(equalTo("2 * x + 14")));
	}
	
	@Test
	def void testVar5() {
		//2*(x+7-(8+x))
		val e = exp(2L,'*',exp(x,"+",7L,"-",exp(8L,"+",x)));
		val r = c.evaluate(e);
		assertThat(printExp(r),is(equalTo("2 * x - 2 - 2 * x")));
	}
	
	@Test
	def void testVar5b() {
		//2*(x+7-(8-x))
		val e = exp(2L,'*',exp(x,"+",7L,"-",exp(8L,"-",x)));
		val r = c.evaluate(e);
		assertThat(printExp(r),is(equalTo("2 * x - 2 + 2 * x")));
	}
	
	@Test
	def void testVar6() {
		//8-(x+4)
		val e = exp(8L,'-',exp(x,'+',4L));
		val r = c.evaluate(e);
		assertThat(printExp(r),is(equalTo("4 - x")));
	}
	
	@Test
	def void testVar7() {
		//x-4+8
		val e = exp(x,'-',4L,'+',8L);
		val r = c.evaluate(e);
		assertThat(printExp(r),is(equalTo("x + 4")));
	}
	
	@Test
	def void testVar8() {
		//x-4-8
		val e = exp(x,'-',4L,'-',8L);
		val r = c.evaluate(e);
		assertThat(printExp(r),is(equalTo("x - 12")));
	}
	
	@Test
	def void testVar9() {
		//x*4*8
		val e = exp(x,'*',4L,'*',8L);
		val r = c.evaluate(e);
		assertThat(printExp(r),is(equalTo("x * 32")));
	}
	
	@Test
	def void testVar10() {
		//x/4*8
		val e = exp(x,'/',4L,'*',8L);
		val r = c.evaluate(e);
		assertThat(printExp(r),is(equalTo("x * 2")));
	}
	
	@Test
	def void testVar11() {
		//x/4/8
		val e = exp(x,'/',4L,'/',8L);
		val r = c.evaluate(e);
		assertThat(printExp(r),is(equalTo("x / 32")));
	}
	
	@Test
	def void testVar12() {
		//2-(x*7/(8*x))
		val e = exp(2L,'-',exp(x,"*",7L,"/",exp(8L,"*",x)));
		val r = c.evaluate(e);
		assertThat(printExp(r),is(equalTo("2 - x * 7 / 8 / x")));
	}
	
	@Test
	def void testVar12b() {
		//2-(x*7/(8*x))
		val e = exp(2L,'-',exp(x,"*",7L,"/",exp(8L,"*",x)));
		b.expressions.add(e);
		c.evaluate(e);
		c.handleDivisions();
		val r = b.expressions.head;
		assertThat(printExp(r),is(equalTo("2")));
	}
	
	@Test
	def void testVar13() {
		//2-(x*7/(8/x))
		val e = exp(2L,'-',exp(x,"*",7L,"/",exp(8L,"/",x)));
		val r = c.evaluate(e);
		assertThat(printExp(r),is(equalTo("2 - x * 7 / 8 * x")));
	}
	
	@Test
	def void testVar13b() {
		//2-(x*7/(8/x))
		val e = exp(2L,'-',exp(x,"*",7L,"/",exp(8L,"/",x)));
		b.expressions.add(e);
		c.evaluate(e);
		c.handleDivisions();
		val r = b.expressions.head;
		assertThat(printExp(r),is(equalTo("2")));
	}
	
	@Test
	def void testDistrib2() {
		//(5+x)*(x+4)
		val e = exp(exp(5L,'+',x),'*',exp(x,"+",4L));
		val r = c.evaluate(e);
		assertThat(printExp(r),is(equalTo("5 * x + 20 + x * x + x * 4")));
	}
	
	@Test
	def void testDistrib3() {
		//(5-x)*(x+4)
		val e = exp(exp(5L,'-',x),'*',exp(x,"+",4L));
		val r = c.evaluate(e);
		assertThat(printExp(r),is(equalTo("5 * x + 20 - x * x - x * 4")));
	}
	
	@Test
	def void testDistrib4() {
		//(5-x)*(x-4)
		val e = exp(exp(5L,'-',x),'*',exp(x,"-",4L));
		val r = c.evaluate(e);
		assertThat(printExp(r),is(equalTo("5 * x - 20 - x * x + x * 4")));
	}
	
	@Test
	def void testNoDistrib() {
		//(5-x)/(x-4)
		val e = exp(exp(5L,'-',x),'/',exp(x,"-",4L));
		val r = c.evaluate(e);
		assertThat(printExp(r),is(equalTo("(5 - x) / (x - 4)")));
	}
	
	@Test
	def void testNoDistrib2() {
		//(5-x)/(x-4)
		val e = exp(exp(5L,'-',x),'/',exp(x,"-",4L));
		b.expressions.add(e);
		c.evaluate(e);
		c.handleDivisions();
		val r = b.expressions.head;
		assertThat(printExp(r),is(equalTo("(5 - x) / (x - 4)")));
	}
	
	@Test
	def void testDistrib5() {
		//(5-x)/2
		val e = exp(exp(5L,'-',x),'/',2L);
		val r = c.evaluate(e);
		assertThat(printExp(r),is(equalTo("(5 - x) / 2")));
	}
	
	@Test
	def void testDistrib5b() {
		//(5-x)/2
		val e = exp(exp(5L,'-',x),'/',2L);
		b.expressions.add(e);
		c.evaluate(e);
		c.handleDivisions();
		val r = b.expressions.head;
		assertThat(printExp(r),is(equalTo("5 - x")));
	}
	
	@Test
	def void testDiv1() {
		//8/2
		val e = exp(8L,'/',2L);
		val r = c.evaluate(e);
		assertThat(r,is(4L));
	}
	
	@Test
	def void testDiv2() {
		//2/8
		val e = exp(2L,'/',8L);
		val r = c.evaluate(e);
		assertThat(printExp(r),is(equalTo("2 / 8")));
	}
	
	@Test
	def void testDiv2b() {
		//2/8
		val e = exp(2L,'/',8L);
		b.expressions.add(e);
		c.evaluate(e);
		c.handleDivisions();
		val r = b.expressions.head;
		assertThat(printExp(r),is(equalTo("0")));
	}
	
	@Test
	def void testDiv3() {
		//2/8/2
		val e = exp(2L,'/',8L,'/',2L);
		val r = c.evaluate(e);
		assertThat(printExp(r),is(equalTo("1 / 8")));
	}
	
	@Test
	def void testDiv3b() {
		//2/8/2
		val e = exp(2L,'/',8L,'/',2L);
		b.expressions.add(e);
		c.evaluate(e);
		c.handleDivisions();
		val r = b.expressions.head;
		assertThat(printExp(r),is(equalTo("0")));
	}
	
	@Test
	def void testDiv4() {
		//2/8/4
		val e = exp(2L,'/',8L,'/',4L);
		val r = c.evaluate(e);
		assertThat(printExp(r),is(equalTo("2 / 32")));
	}
	
	@Test
	def void testDiv4b() {
		//2/8/4
		val e = exp(2L,'/',8L,'/',4L);
		b.expressions.add(e);
		c.evaluate(e);
		c.handleDivisions();
		val r = b.expressions.head;
		assertThat(printExp(r),is(equalTo("0")));
	}
	
	@Test
	def void testDiv5() {
		//2/8*4
		val e = exp(2L,'/',8L,'*',4L);
		val r = c.evaluate(e);
		assertThat(r,is(1L));
	}
	
	@Test
	def void testDiv6() {
		//x/8*4
		val e = exp(x,'/',8L,'*',4L);
		val r = c.evaluate(e);
		assertThat(printExp(r),is(equalTo("x / 2")));
	}
	
	@Test
	def void testDiv6b() {
		//x/8*4
		val e = exp(x,'/',8L,'*',4L);
		b.expressions.add(e);
		c.evaluate(e);
		c.handleDivisions();
		val r = b.expressions.head;
		assertThat(printExp(r),is(equalTo("x")));
	}
	
	@Test
	def void testDivBy0() {
		//2/0
		val e = exp(2L,'/',0L);
		val r = c.evaluate(e);
		assertThat(printExp(r),is(equalTo("2 / 0")));
	}

	@Test
	def void testMod1() {
		// 10 % 2
		val e = exp(10L,'%',2L);
		val r = c.evaluate(e);
		assertThat(r,is(0L));
	}
	
	@Test
	def void testMod2() {
		// 10 % 3
		val e = exp(10L,'%',3L);
		val r = c.evaluate(e);
		assertThat(r,is(1L));
	}
	
	@Test
	def void testMod3() {
		// 10 % 4 * 3
		val e = exp(10L,'%',4L,'*',3L);
		val r = c.evaluate(e);
		assertThat(r,is(6L));
	}
	
	@Test
	def void testMod4() {
		// x % 4 * 3
		val e = exp(x,'%',4L,'*',3L);
		val r = c.evaluate(e);
		assertThat(printExp(r),is(equalTo("x % 4 * 3")));
	}
	
	@Test
	def void testMod5() {
		// 4 % x * 3
		val e = exp(4L,'%',x,'*',3L);
		val r = c.evaluate(e);
		assertThat(printExp(r),is(equalTo("4 % x * 3")));
	}
	
	@Test
	def void testBool1() {
		// 1 > 0
		val e = exp(1L,'>',0L);
		val r = c.evaluate(e);
		assertThat(r,is(1L));
	}
	
	@Test
	def void testBool2() {
		// 1 < 0
		val e = exp(1L,'<',0L);
		val r = c.evaluate(e);
		assertThat(r,is(0L));
	}
	
	@Test
	def void testBool3() {
		// 7*2 <= 14
		val e = exp(exp(7L,'*',2L),'<=',14L);
		val r = c.evaluate(e);
		assertThat(r,is(1L));
	}
	
	@Test
	def void testBool4() {
		// 7*2 >= 14
		val e = exp(exp(7L,'*',2L),'>=',14L);
		val r = c.evaluate(e);
		assertThat(r,is(1L));
	}
	
	@Test
	def void testBool5() {
		// 1 = 2
		val e = exp(1L,'=',2L);
		val r = c.evaluate(e);
		assertThat(r,is(0L));
	}
	
	@Test
	def void testBool6() {
		// 1 = 2
		val e = exp(1L,'!=',2L);
		val r = c.evaluate(e);
		assertThat(r,is(1L));
	}
	
	@Test
	def void testNeutral1() {
		// x+0
		val e = exp(x,'+',0L);
		val r = c.evaluate(e);
		assertThat(printExp(r),is(equalTo("x")));
	}
	
	@Test
	def void testNeutral2() {
		// 0+x
		val e = exp(0L,'+',x);
		val r = c.evaluate(e);
		assertThat(printExp(r),is(equalTo("x")));
	}
	
	@Test
	def void testNeutral3() {
		// x-0
		val e = exp(x,'-',0L);
		val r = c.evaluate(e);
		assertThat(printExp(r),is(equalTo("x")));
	}
	
	@Test
	def void testNeutral4() {
		// x*1
		val e = exp(x,'*',1L);
		val r = c.evaluate(e);
		assertThat(printExp(r),is(equalTo("x")));
	}
	
	@Test
	def void testNeutral5() {
		// 1*x
		val e = exp(1L,'*',x);
		val r = c.evaluate(e);
		assertThat(printExp(r),is(equalTo("x")));
	}
	
	@Test
	def void testNeutral6() {
		// x/1
		val e = exp(x,'/',1L);
		val r = c.evaluate(e);
		assertThat(printExp(r),is(equalTo("x")));
	}
	
	@Test
	def void testMult0() {
		// (2*x+7)*x*0
		val e = exp(exp(exp(2L,'*',x),'+',7L),'*',x,'*',0L);
		val r = c.evaluate(e);
		assertThat(printExp(r),is(equalTo("0")));
	}
	
}
