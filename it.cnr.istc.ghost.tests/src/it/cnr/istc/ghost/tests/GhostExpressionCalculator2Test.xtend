/*
 * generated by Xtext 2.12.0
 */
package it.cnr.istc.ghost.tests

import com.google.inject.Inject
import it.cnr.istc.ghost.generator.internal.BlockAdapter
import it.cnr.istc.ghost.generator.internal.BlockImpl
import it.cnr.istc.ghost.generator.internal.ExpressionCalculator
import it.cnr.istc.ghost.generator.internal.ExpressionImpl
import it.cnr.istc.ghost.generator.internal.Register
import it.cnr.istc.timeline.lang.Variable
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.XtextRunner
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith

import static org.hamcrest.CoreMatchers.*
import static org.junit.Assert.*
import it.cnr.istc.ghost.generator.internal.VariableProxy
import com.google.common.collect.Lists
import java.util.List

@RunWith(XtextRunner)
@InjectWith(GhostInjectorProvider)
class GhostExpressionCalculator2Test{

	@Inject
	Register register;

	ExpressionCalculator c;
	BlockImpl b;
	
	VariableProxy x = new VariableProxy("x",null);
	VariableProxy y = new VariableProxy("y",null); 
	
	BlockAdapter ba = new BlockAdapter(){
		List<Variable> l = Lists.newArrayList(x,y);
		
		override getContents() {
			return l
		}
		
		override getContainer() {
			return null;
		}
		
		override <T extends EObject> getContainerOfType(Class<T> clazz) {
			return null;
		}
		
	}

	@Before
	def void setup() {
		b = new BlockImpl(ba,null,register);
		c = new ExpressionCalculator(b);
	}

	def ExpressionImpl exp(Object ... data) {
		val e = new ExpressionImpl(null,register);
		e.operands.set(0,data.get(0));
		var i = 1; 
		while (i+1 < data.size()) {
			e.operators.add(data.get(i) as String);
			e.operands.add(data.get(i+1));
			i+=2;
		}
		return e;
	}
	
	private def int getOpDegree(String op) {
		return
		switch (op) {
			case '*', case '/', case '%': 1
			case '+', case '-': 2
			case '<', case '<=', case '>', case '>=' : 3
			case '=', case '!=' : 4
			default: 0
		}
	}
	
	private def getExpDegree(ExpressionImpl exp) {
		if (exp.operators.size()>0) return getOpDegree(exp.operators.get(0))
		return 0;
	}
	
	def dispatch String printExp(ExpressionImpl exp) {
		var str = "";
		for (var i = 0; i < exp.operands.size(); i++) {
			val sub = exp.operands.get(i);
			var subStr = printExp(sub);
			if (sub instanceof ExpressionImpl && exp.operators.size()>0) {
				val op = exp.operators.get(0);
				val needParens = getOpDegree(op) <= getExpDegree(sub as ExpressionImpl);
				if (needParens) subStr = "("+subStr+")";	
			}
			str+=subStr;
			if (i < exp.operators.size())
				str+= " "+exp.operators.get(i)+" ";
		}
		
		return str.trim();
	}

	def dispatch String printExp(Variable exp) {
		return exp.name;
	}
	
	def dispatch String printExp(Object exp) {
		return ""+exp;
	}
	
	def dispatch String printExp(Void exp) { "" }
	
	
	@Test
	def void testDivisionInEquation1() {
		// y = x/2
		y.value = exp(x,'/',2L);
		c.evaluate(y.value);
		c.handleDivisions();
		val r = b.expressions.head;
		assertThat(printExp(r),is(equalTo("2 * y = x")));
		assertThat(y.value,is(nullValue));
	}
	
	@Test
	def void testDivisionInEquation2() {
		// y = (5-x)/2
		y.value = exp(exp(5L,'-',x),'/',2L);
		c.evaluate(y.value);
		c.handleDivisions();
		val r = b.expressions.head;
		assertThat(printExp(r),is(equalTo("2 * y = 5 - x")));
	}
	
	@Test
	def void testDivisionInEquation3() {
		// y = (5-x)/(7-x)/2
		y.value = exp(exp(5L,'-',x),'/',exp(7L,'-',x),'/',2L);
		c.evaluate(y.value);
		c.handleDivisions();
		val r = b.expressions.head;
		assertThat(printExp(r),is(equalTo("2 * y = (5 - x) / (7 - x)")));
	}
	
	@Test
	def void testDivisionInEquation4() {
		// y = x/2 + x/3
		y.value = exp(exp(x,'/',2L),'+',exp(x,'/',3L));
		c.evaluate(y.value);
		c.handleDivisions();
		val r = b.expressions.head;
		assertThat(printExp(r),is(equalTo("6 * y = 3 * x + 2 * x")));
	}
	
	
	
	
	
}
