/*
 * generated by Xtext 2.12.0
 */
package it.cnr.istc.ghost.tests

import com.google.inject.Inject
import it.cnr.istc.ghost.generator.internal.ExpressionImpl
import it.cnr.istc.ghost.generator.internal.Register
import it.cnr.istc.timeline.lang.Variable
import java.util.Collections
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.XtextRunner
import org.junit.Test
import org.junit.runner.RunWith

import static org.hamcrest.CoreMatchers.*
import static org.junit.Assert.*
import it.cnr.istc.ghost.generator.internal.VariableProxy
import it.cnr.istc.ghost.generator.DdlExpressionFormatter
import it.cnr.istc.ghost.generator.internal.ParameterImpl
import it.cnr.istc.timeline.lang.IntType
import it.cnr.istc.timeline.lang.Interval
import it.cnr.istc.ghost.generator.internal.IntervalImpl
import it.cnr.istc.timeline.lang.EnumType
import it.cnr.istc.timeline.lang.EnumLiteral
import it.cnr.istc.ghost.generator.internal.InstantiatedValueImpl
import it.cnr.istc.timeline.lang.Value
import java.util.List
import it.cnr.istc.timeline.lang.Parameter
import it.cnr.istc.timeline.lang.Component
import it.cnr.istc.timeline.lang.ResourceAction
import it.cnr.istc.timeline.lang.Fact
import it.cnr.istc.ghost.generator.internal.TimePointOperationImpl
import it.cnr.istc.timeline.lang.TimePointSelector
import it.cnr.istc.timeline.lang.ComponentVariable

@RunWith(XtextRunner)
@InjectWith(GhostInjectorProvider)
class DdlExpressionFormatterTest{

	@Inject
	Register register;

	@Inject
	DdlExpressionFormatter f;
	
	Variable x = new VariableProxy("x",null);
	
	Interval intv = new IntervalImpl(10,20);
	
	IntType inttype = new IntType(){
		override getInterval() {
			intv
		}
		override getName() {
			return "AIntType";
		}
	}
	
	EnumLiteral el1 = new EnumLiteral() {
		override getEnum() { return entype; }
		override getName() { return "EN1"; }
	}
	
	EnumLiteral el2 = new EnumLiteral() {
		override getEnum() { return entype; }
		override getName() { return "EN2"; }
	}
	
	EnumType entype = new EnumType() {
		override getValues() {
			return #[el1,el2];
		}
		
		override getName() {
			return "AEnumType";
		}
	}
	
	ComponentVariable cvar = new ComponentVariable() {
		override getName() { "cvar"}
		override getType() { null }
	}
	
	Component comp = new Component() {
		override getName() { "comp1";}
		override getType() { null; }
		override getVariableBindings() {#[]}
		override getVariableMapping() {#{cvar -> comp}}
	}
	
	Value aValue = new Value(){
		override getFormalParameters() { #[] }
		override getName() { "AValue" }
	}
	
	def ExpressionImpl exp(Object ... data) {
		val e = new ExpressionImpl(null,register);
		e.operands.set(0,data.get(0));
		var i = 1; 
		while (i+1 < data.size()) {
			e.operators.add(data.get(i) as String);
			e.operands.add(data.get(i+1));
			i+=2;
		}
		return e;
	}

	@Test
	def void testNum1() {
		//1
		val e = exp(1L);
		val r = f.formatExpression(e,null);
		assertThat(r,is(equalTo("1")));
	}
	
	@Test
	def void testNum2() {
		//1
		val r = f.formatExpression(1L,null);
		assertThat(r,is(equalTo("1")));
	}
	
	@Test
	def void testNumInf() {
		//1
		val e = exp(Long.MAX_VALUE);
		val r = f.formatExpression(e,null);
		assertThat(r,is(equalTo("INF")));
	}
	
	@Test
	def void testNumMinusInf() {
		//1
		val e = exp(Long.MIN_VALUE);
		val r = f.formatExpression(e,null);
		assertThat(r,is(equalTo("-INF")));
	}
	
	@Test
	def void testVar1() {
		//x
		val r = f.formatExpression(x,null);
		assertThat(r,is(equalTo("?x")));
	}
	
	@Test
	def void testParam1() {
		//par
		val par = new ParameterImpl("par",inttype);
		val r = f.formatExpression(par,null);
		assertThat(r,is(equalTo("?par")));
	}
	
	@Test
	def void testEnLiteral1() {
		//EN1
		val r = f.formatExpression(el1,null);
		assertThat(r,is(equalTo("EN1")));
	}
	
	@Test
	def void testVoid() {
		//""
		val r = f.formatExpression(null,null);
		assertThat(r,is(equalTo("")));
	}
	
	@Test
	def void testInvalid() {
		//""
		val r = f.formatExpression("invalid",null);
		assertThat(r,is(equalTo("<ERROR:>invalid")));
	}
	
	@Test
	def void testExpPlus() {
		//1+2
		val e = exp(1L,'+',2L);
		val r = f.formatExpression(e,null);
		assertThat(r,is(equalTo("1 + 2")));
	}
	
	@Test
	def void testExpMinus() {
		//1-2
		val e = exp(1L,'-',2L);
		val r = f.formatExpression(e,null);
		assertThat(r,is(equalTo("1 - 2")));
	}
	
	@Test
	def void testExpStar() {
		//1*2
		val e = exp(1L,'*',2L);
		val r = f.formatExpression(e,null);
		assertThat(r,is(equalTo("1 * 2")));
	}
	
	@Test
	def void testExpDiv() {
		//1/2
		val e = exp(1L,'/',2L);
		val r = f.formatExpression(e,null);
		assertThat(r,is(equalTo("1 / 2")));
	}
	
	@Test
	def void testExpMod() {
		//1%2
		val e = exp(1L,'%',2L);
		val r = f.formatExpression(e,null);
		assertThat(r,is(equalTo("1 % 2")));
	}
	
	@Test
	def void testExpLess() {
		//1<2
		val e = exp(1L,'<',2L);
		val r = f.formatExpression(e,null);
		assertThat(r,is(equalTo("1 < 2")));
	}
	
	@Test
	def void testExpLeq() {
		//1<2
		val e = exp(1L,'<=',2L);
		val r = f.formatExpression(e,null);
		assertThat(r,is(equalTo("1 <= 2")));
	}
	
	@Test
	def void testExpGreater() {
		//1<2
		val e = exp(1L,'>',2L);
		val r = f.formatExpression(e,null);
		assertThat(r,is(equalTo("1 > 2")));
	}
	
	@Test
	def void testExpGeq() {
		//1<2
		val e = exp(1L,'>=',2L);
		val r = f.formatExpression(e,null);
		assertThat(r,is(equalTo("1 >= 2")));
	}
	
	@Test
	def void testExpEquals() {
		//1<2
		val e = exp(1L,'=',2L);
		val r = f.formatExpression(e,null);
		assertThat(r,is(equalTo("1 = 2")));
	}
	
	@Test
	def void testExpMulti1() {
		//1+2-7-4+3
		val e = exp(1L,'+',2L,'-',7L,'-',4L,'+',3L);
		val r = f.formatExpression(e,null);
		assertThat(r,is(equalTo("1 + 2 - 7 - 4 + 3")));
	}
	
	@Test
	def void testExpMulti2() {
		//1*2/7/4*3
		val e = exp(1L,'*',2L,'/',7L,'/',4L,'*',3L);
		val r = f.formatExpression(e,null);
		assertThat(r,is(equalTo("1 * 2 / 7 / 4 * 3")));
	}
	
	@Test
	def void testExpMulti3() {
		//7 >= 2 < 1
		val e = exp(7L,'>=',2L,'<',1L);
		val r = f.formatExpression(e,null);
		assertThat(r,is(equalTo("7 >= 2 < 1")));
	}
	
	@Test
	def void testExpMulti4() {
		//2 = 2 = 1
		val e = exp(2L,'=',2L,'=',1L);
		val r = f.formatExpression(e,null);
		assertThat(r,is(equalTo("2 = 2 = 1")));
	}
	
	@Test
	def void testPrecedence1() {
		//7+3*2
		val e = exp(7L,'+',exp(3L,'*',2L));
		val r = f.formatExpression(e,null);
		assertThat(r,is(equalTo("7 + 3 * 2")));
	}
	
	@Test
	def void testPrecedence2() {
		//7*(3+2)
		val e = exp(7L,'*',exp(3L,'+',2L));
		val r = f.formatExpression(e,null);
		assertThat(r,is(equalTo("7 * (3 + 2)")));
	}
	
	@Test
	def void testPrecedence3() {
		//(3+2)*7
		val e = exp(exp(3L,'+',2L),'*',7L);
		val r = f.formatExpression(e,null);
		assertThat(r,is(equalTo("(3 + 2) * 7")));
	}
	
	@Test
	def void testPrecedence4() {
		//(3+2)*(7+5)
		val e = exp(exp(3L,'+',2L),'*',exp(7L,'+',5L));
		val r = f.formatExpression(e,null);
		assertThat(r,is(equalTo("(3 + 2) * (7 + 5)")));
	}
	
	@Test
	def void testPrecedence5() {
		//(3+2*(4+6))*(7+5)
		val e = exp(exp(3L,'+',exp(2L,'*',exp(4L,'+',6L))),'*',exp(7L,'+',5L));
		val r = f.formatExpression(e,null);
		assertThat(r,is(equalTo("(3 + 2 * (4 + 6)) * (7 + 5)")));
	}
	
	@Test
	def void testPrecedence6() {
		// 10 > 1 = 7 < 10 + 7*4 
		val e = exp(exp(10L,'>',1L),'=',exp(7L,'<',exp(10L,'+',exp(7L,'*',4L))));
		val r = f.formatExpression(e,null);
		assertThat(r,is(equalTo("10 > 1 = 7 < 10 + 7 * 4")));
	}
	
	@Test
	def void testIV1() {
		val iv = new InstantiatedValueImpl(null,aValue,Collections.emptyList());
		val r = f.formatExpression(iv,null);
		assertThat(r,is(equalTo("AValue()")));
	}
	
	@Test
	def void testIV2() {
		val value = new Value(){
			List<Parameter> plist = #[new ParameterImpl("par1",inttype),new ParameterImpl("par2",inttype)];
			override getFormalParameters() {
				return plist;
			}
			override getName() { "AValue" }
		}
		val iv = new InstantiatedValueImpl(null,value,#[10L,20L]);
		val r = f.formatExpression(iv,null);
		assertThat(r,is(equalTo("AValue(10, 20)")));
	}
	
	@Test
	def void testIV3() {
		val value = new Value(){
			List<Parameter> plist = #[new ParameterImpl("par1",inttype),new ParameterImpl("par2",inttype)];
			override getFormalParameters() {
				return plist;
			}
			override getName() { "AValue" }
		}
		val iv = new InstantiatedValueImpl(comp,value,#[10L,20L]);
		val r = f.formatExpression(iv,null);
		assertThat(r,is(equalTo("comp1.timeline.AValue(10, 20)")));
	}
	
	@Test
	def void testIVRes1() {
		val value = ResourceAction.REQUIRE;
		val iv = new InstantiatedValueImpl(null,value,#[10L]);
		val r = f.formatExpression(iv,null);
		assertThat(r,is(equalTo("REQUIREMENT(10)")));
	}
	
	@Test
	def void testIVRes2() {
		val value = ResourceAction.REQUIRE;
		val iv = new InstantiatedValueImpl(comp,value,#[10L]);
		val r = f.formatExpression(iv,null);
		assertThat(r,is(equalTo("comp1.timeline.REQUIREMENT(10)")));
	}
	
	@Test
	def void testIVRes3() {
		val value = ResourceAction.PRODUCE;
		val iv = new InstantiatedValueImpl(comp,value,#[10L]);
		val r = f.formatExpression(iv,null);
		assertThat(r,is(equalTo("comp1.timeline.PRODUCTION(10)")));
	}
	
	@Test
	def void testIVRes4() {
		val value = ResourceAction.CONSUME;
		val iv = new InstantiatedValueImpl(comp,value,#[10L]);
		val r = f.formatExpression(iv,null);
		assertThat(r,is(equalTo("comp1.timeline.CONSUMPTION(10)")));
	}
	
	@Test
	def void testFact1() {
		val iv = new InstantiatedValueImpl(comp,aValue,Collections.emptyList());
		
		val fact = new Fact() {
			override getStart() { new IntervalImpl(10,10)}
			override getEnd() { new IntervalImpl(50,50)}
			override getDuration() { new IntervalImpl(40,40)}
			override getValue() { iv }
			override isGoal() { false; }
		}
		val r = f.formatExpression(fact,null);
		assertThat(r,is(equalTo("<fact> comp1.timeline.AValue() AT [10, 10] [40, 40] [50, 50]")));
	}
	
	@Test
	def void testGoal1() {
		val iv = new InstantiatedValueImpl(comp,aValue,Collections.emptyList());
		
		val fact = new Fact() {
			override getStart() { new IntervalImpl(10,10)}
			override getEnd() { new IntervalImpl(50,50)}
			override getDuration() { new IntervalImpl(40,40)}
			override getValue() { iv }
			override isGoal() { true; }
		}
		val r = f.formatExpression(fact,null);
		assertThat(r,is(equalTo("<goal> comp1.timeline.AValue() AT [10, 10] [40, 40] [50, 50]")));
	}
	
	@Test
	def void testTimepointOp1() {
		val iv = new InstantiatedValueImpl(comp,aValue,Collections.emptyList());
		val tpo = new TimePointOperationImpl(iv,TimePointSelector.START);
		val r = f.formatExpression(tpo,null);
		//string rep of TimePointOp is same of its InstantiatedValue. It is on purpose.
		assertThat(r,is(equalTo("comp1.timeline.AValue()")));
	}
	
	@Test
	def void testVar2() {
		val iv = new InstantiatedValueImpl(null,aValue,Collections.emptyList());
		val var2 = new VariableProxy("icd",iv);
		val r = f.formatExpression(var2,null);
		//string rep of TimePointOp is same of its InstantiatedValue. It is on purpose.
		assertThat(r,is(equalTo("icd")));
	}
	
	@Test
	def void testObjVar1() {
		val iv = new InstantiatedValueImpl(cvar,aValue,Collections.emptyList());
		val r = f.formatExpression(iv,comp);
		assertThat(r,is(equalTo("comp1.timeline.AValue()")));
	}
	
}
