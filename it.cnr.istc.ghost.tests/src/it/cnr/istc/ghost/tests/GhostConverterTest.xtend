/*
 * generated by Xtext 2.10.0
 */
package it.cnr.istc.ghost.tests

import com.google.inject.Inject
import it.cnr.istc.ghost.ghost.Ghost
import it.cnr.istc.ghost.conversion.NumberValueConverter
import org.eclipse.xtext.junit4.InjectWith
import org.eclipse.xtext.junit4.XtextRunner
import org.eclipse.xtext.junit4.util.ParseHelper
import org.junit.Test
import org.junit.runner.RunWith

import static org.junit.Assert.*
import static org.hamcrest.CoreMatchers.*
import org.eclipse.xtext.EcoreUtil2
import it.cnr.istc.ghost.ghost.Interval
import org.eclipse.xtext.nodemodel.util.NodeModelUtils
import it.cnr.istc.ghost.ghost.GhostPackage
import org.eclipse.xtext.conversion.ValueConverterException

@RunWith(XtextRunner)
@InjectWith(GhostInjectorProvider)
class GhostConverterTest{

	@Inject
	ParseHelper<Ghost> parseHelper
	
	@Inject
	NumberValueConverter converter;

	@Test
	def void testToValueNoSign() {
		val result = parseHelper.parse('''
type test = int [0, 100];
		''')
		val intv = EcoreUtil2.eAllOfType(result,Interval).head;
		val node = NodeModelUtils.findNodesForFeature(intv,GhostPackage.Literals.INTERVAL__UB).head;
		val value = converter.toValue(intv.ub,node);
		assertThat(value,is(100L));
	}
	
	@Test
	def void testToValuePositive() {
		val result = parseHelper.parse('''
type test = int [0, +100];
		''')
		val intv = EcoreUtil2.eAllOfType(result,Interval).head;
		val node = NodeModelUtils.findNodesForFeature(intv,GhostPackage.Literals.INTERVAL__UB).head;
		val value = converter.toValue(intv.ub,node);
		assertThat(value,is(100L));
	}
	
	@Test
	def void testToValueNegative() {
		val result = parseHelper.parse('''
type test = int [0, -100];
		''')
		val intv = EcoreUtil2.eAllOfType(result,Interval).head;
		val node = NodeModelUtils.findNodesForFeature(intv,GhostPackage.Literals.INTERVAL__UB).head;
		val value = converter.toValue(intv.ub,node);
		assertThat(value,is(-100L));
	}
	
	@Test
	def void testToValueZero() {
		val result = parseHelper.parse('''
type test = int [0, 0];
		''')
		val intv = EcoreUtil2.eAllOfType(result,Interval).head;
		val node = NodeModelUtils.findNodesForFeature(intv,GhostPackage.Literals.INTERVAL__UB).head;
		val value = converter.toValue(intv.ub,node);
		assertThat(value,is(0L));
	}
	
	@Test
	def void testToValuePositiveZero() {
		val result = parseHelper.parse('''
type test = int [0, +0];
		''')
		val intv = EcoreUtil2.eAllOfType(result,Interval).head;
		val node = NodeModelUtils.findNodesForFeature(intv,GhostPackage.Literals.INTERVAL__UB).head;
		val value = converter.toValue(intv.ub,node);
		assertThat(value,is(0L));
	}
	
	@Test
	def void testToValueNegativeZero() {
		val result = parseHelper.parse('''
type test = int [0, -0];
		''')
		val intv = EcoreUtil2.eAllOfType(result,Interval).head;
		val node = NodeModelUtils.findNodesForFeature(intv,GhostPackage.Literals.INTERVAL__UB).head;
		val value = converter.toValue(intv.ub,node);
		assertThat(value,is(0L));
	}
	
	@Test
	def void testToValueInfinity() {
		val result = parseHelper.parse('''
type test = int [0, INF];
		''')
		val intv = EcoreUtil2.eAllOfType(result,Interval).head;
		val node = NodeModelUtils.findNodesForFeature(intv,GhostPackage.Literals.INTERVAL__UB).head;
		val value = converter.toValue(intv.ub,node);
		assertThat(value,is(Long.MAX_VALUE));
	}
	
	@Test
	def void testToValuePositiveInfinity() {
		val result = parseHelper.parse('''
type test = int [0, +INF];
		''')
		val intv = EcoreUtil2.eAllOfType(result,Interval).head;
		val node = NodeModelUtils.findNodesForFeature(intv,GhostPackage.Literals.INTERVAL__UB).head;
		val value = converter.toValue(intv.ub,node);
		assertThat(value,is(Long.MAX_VALUE));
	}
	
	@Test
	def void testToValueNegativeInfinity() {
		val result = parseHelper.parse('''
type test = int [0, -INF];
		''')
		val intv = EcoreUtil2.eAllOfType(result,Interval).head;
		val node = NodeModelUtils.findNodesForFeature(intv,GhostPackage.Literals.INTERVAL__UB).head;
		val value = converter.toValue(intv.ub,node);
		assertThat(value,is(Long.MIN_VALUE));
	}
	
	@Test
	def void testToValueSpaceSign() {
		val result = parseHelper.parse('''
type test = int [0, - 100];
		''')
		val intv = EcoreUtil2.eAllOfType(result,Interval).head;
		val node = NodeModelUtils.findNodesForFeature(intv,GhostPackage.Literals.INTERVAL__UB).head;
		val value = converter.toValue(intv.ub,node);
		assertThat(value,is(-100L));
	}
	
	@Test
	def void testToValuePositiveInfinitySpace() {
		val result = parseHelper.parse('''
type test = int [0, + INF];
		''')
		val intv = EcoreUtil2.eAllOfType(result,Interval).head;
		val node = NodeModelUtils.findNodesForFeature(intv,GhostPackage.Literals.INTERVAL__UB).head;
		val value = converter.toValue(intv.ub,node);
		assertThat(value,is(Long.MAX_VALUE));
	}
	
	@Test
	def void testToValueNegativeInfinitySpace() {
		val result = parseHelper.parse('''
type test = int [0, - INF];
		''')
		val intv = EcoreUtil2.eAllOfType(result,Interval).head;
		val node = NodeModelUtils.findNodesForFeature(intv,GhostPackage.Literals.INTERVAL__UB).head;
		val value = converter.toValue(intv.ub,node);
		assertThat(value,is(Long.MIN_VALUE));
	}
	
	@Test(expected = ValueConverterException)
	def void testToValueEmpty() {
		val result = parseHelper.parse('''
type test = int [0, 100];
		''')
		val intv = EcoreUtil2.eAllOfType(result,Interval).head;
		val node = NodeModelUtils.findNodesForFeature(intv,GhostPackage.Literals.INTERVAL__UB).head;
		converter.toValue("",node);
	}
	
	@Test(expected = ValueConverterException)
	def void testToValueInvalid() {
		val result = parseHelper.parse('''
type test = int [0, 100];
		''')
		val intv = EcoreUtil2.eAllOfType(result,Interval).head;
		val node = NodeModelUtils.findNodesForFeature(intv,GhostPackage.Literals.INTERVAL__UB).head;
		converter.toValue("onehundred",node);
	}
	
	@Test
	def void testToStringPositive() {
		val value = converter.toString(100L);
		assertThat(value,is(equalTo("100")));
	}
	
	@Test
	def void testToStringNegative() {
		val value = converter.toString(-100L);
		assertThat(value,is(equalTo("-100")));
	}
	
	@Test
	def void testToStringPositiveInfinity() {
		val value = converter.toString(Long.MAX_VALUE);
		assertThat(value,is(equalTo("+INF")));
	}
	
	@Test
	def void testToStringNegativeInfinity() {
		val value = converter.toString(Long.MIN_VALUE);
		assertThat(value,is(equalTo("-INF")));
	}
	
}
