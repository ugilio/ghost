/*
 * generated by Xtext 2.12.0
 */
package it.cnr.istc.ghost.tests

import com.google.inject.Inject
import it.cnr.istc.ghost.ghost.Ghost
import it.cnr.istc.ghost.ghost.GhostPackage
import it.cnr.istc.ghost.validation.GhostValidator
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.XtextRunner
import org.eclipse.xtext.testing.util.ParseHelper
import org.eclipse.xtext.testing.validation.ValidationTestHelper
import org.junit.Test
import org.junit.runner.RunWith

@RunWith(XtextRunner)
@InjectWith(GhostInjectorProvider)
class GhostExpressionValidator2Test{

	@Inject extension ParseHelper<Ghost>
	@Inject extension ValidationTestHelper
	
	@Test
	def void testComparisonDiffTypes() {
		val model = '''
type e = enum(EN1,EN2);
comp c : sv (
	A -> 1 = EN1;
)
		'''.parse;
		model.assertWarning(GhostPackage.Literals.EXPRESSION,
			GhostValidator.COMPARISON_DIFFERENT_TYPES);
	}
	
	@Test
	def void testBoolNum() {
		val model = '''
comp c : sv (
	A -> 1 + (1 > 0);
)
		'''.parse;
		model.assertWarning(GhostPackage.Literals.EXPRESSION,
			GhostValidator.BOOLEAN_TO_NUMERIC);
	}
	
	@Test
	def void testExpected1() {
		val model = '''
type e = enum(EN1,EN2);
comp c : sv (
	A -> 1 + EN1;
)
		'''.parse;
		model.assertError(GhostPackage.Literals.EXPRESSION,
			GhostValidator.EXPECTED_TYPE);
	}
	
	@Test
	def void testExpected2() {
		val model = '''
comp c : sv (
	A -> start(A) + 1;
)
		'''.parse;
		model.assertError(GhostPackage.Literals.EXPRESSION,
			GhostValidator.EXPECTED_TYPE);
	}
	
	//Unused variables
	@Test
	def void testUnusedVar1() {
		val model = '''
comp c : sv (
	A -> var x = 12;
);
		'''.parse;
		model.assertWarning(GhostPackage.Literals.TRANS_CONSTR_BODY, GhostValidator.UNUSED_VAR);
	}
	
	@Test
	def void testUnusedVar2() {
		val model = '''
comp c : sv (
	A -> (var x = 12, x > 10);
);
		'''.parse;
		model.assertNoIssues();
	}
	
	@Test
	def void testLocVarInvalidType() {
		val model = '''
comp C: sv(
	A
synchronize:
	A -> (var constraint = this = A; constraint);
);
		'''.parse;
		model.assertError(GhostPackage.Literals.LOC_VAR_DECL, GhostValidator.LOCVAR_TEMPORAL_EXP);
	}	
	
	//Useless expressions
	@Test
	def void testUselessExp1() {
		val model = '''
comp c : sv (
	A -> 15
);
		'''.parse;
		model.assertWarning(GhostPackage.Literals.TRANS_CONSTR_BODY, GhostValidator.USELESS_EXPRESSION);
	}
	
	@Test
	def void testUselessExp2() {
		val model = '''
comp c : sv (
	A, B
synchronize:
	A -> B
);
		'''.parse;
		model.assertWarning(GhostPackage.Literals.SYNC_BODY, GhostValidator.USELESS_EXPRESSION);
	}
	
	@Test
	def void testUselessExp3() {
		val model = '''
type e = enum(E1,E2);
comp c : sv (
	A -> E1
);
		'''.parse;
		model.assertWarning(GhostPackage.Literals.TRANS_CONSTR_BODY, GhostValidator.USELESS_EXPRESSION);
	}
	
	@Test
	def void testNotUselessExp1() {
		val model = '''
comp c : sv (
	A -> var x = 15
);
		'''.parse;
		model.assertNoIssue(GhostPackage.Literals.TRANS_CONSTR_BODY, GhostValidator.USELESS_EXPRESSION);
	}
	
	@Test
	def void testNotUselessExp2() {
		val model = '''
comp c : sv (
	A -> B, B
);
		'''.parse;
		model.assertNoIssue(GhostPackage.Literals.TRANS_CONSTR_BODY, GhostValidator.USELESS_EXPRESSION);
	}
	
	@Test
	def void testNotUselessExp3() {
		val model = '''
comp c : sv (
	A -> 10 < 15
);
		'''.parse;
		model.assertNoIssue(GhostPackage.Literals.TRANS_CONSTR_BODY, GhostValidator.USELESS_EXPRESSION);
	}
	
	@Test
	def void testNotUselessExp4() {
		val model = '''
comp c : sv (
	A, B
synchronize:
	A -> EQUALS B
);
		'''.parse;
		model.assertNoIssue(GhostPackage.Literals.SYNC_BODY, GhostValidator.USELESS_EXPRESSION);
	}
	
	@Test
	def void testNotUselessExp5() {
		val model = '''
comp r : resource(10);
comp c : sv (
	A, B
synchronize:
	A -> require r(10);
);
		'''.parse;
		model.assertNoIssues();
	}
	
	@Test
	def void testIncompTempOpPointPoint1() {
		val model = '''
comp c : sv (
	A,B
synchronize:
	A -> start(A) meets start(B)
)
		'''.parse;
		model.assertError(GhostPackage.Literals.EXPRESSION,
			GhostValidator.TEMPOP_INCOMPATIBLE);
	}
	
	@Test
	def void testIncompTempOpPointPoint2() {
		val model = '''
comp c : sv (
	A,B
synchronize:
	A -> start(A) |= start(B)
)
		'''.parse;
		model.assertError(GhostPackage.Literals.EXPRESSION,
			GhostValidator.TEMPOP_INCOMPATIBLE);
	}
	
	@Test
	def void testIncompTempOpPointPoint3() {
		val model = '''
comp c : sv (
	A,B
synchronize:
	A -> start(A) starts start(B)
)
		'''.parse;
		model.assertError(GhostPackage.Literals.EXPRESSION,
			GhostValidator.TEMPOP_INCOMPATIBLE);
	}
	
	@Test
	def void testIncompTempOpPointPoint4() {
		val model = '''
comp c : sv (
	A,B
synchronize:
	A -> start(A) finishes start(B)
)
		'''.parse;
		model.assertError(GhostPackage.Literals.EXPRESSION,
			GhostValidator.TEMPOP_INCOMPATIBLE);
	}
	
	@Test
	def void testIncompTempOpPointPoint5() {
		val model = '''
comp c : sv (
	A,B
synchronize:
	A -> start(A) contains start(B)
)
		'''.parse;
		model.assertError(GhostPackage.Literals.EXPRESSION,
			GhostValidator.TEMPOP_INCOMPATIBLE);
	}
	
	@Test
	def void testIncompTempOpPointPoint6() {
		val model = '''
comp c : sv (
	A,B
synchronize:
	A -> start(A) during start(B)
)
		'''.parse;
		model.assertError(GhostPackage.Literals.EXPRESSION,
			GhostValidator.TEMPOP_INCOMPATIBLE);
	}
	
	@Test
	def void testIncompTempOpIntvPoint1() {
		val model = '''
comp c : sv (
	A,B
synchronize:
	A -> A = start(B)
)
		'''.parse;
		model.assertError(GhostPackage.Literals.EXPRESSION,
			GhostValidator.TEMPOP_INCOMPATIBLE);
	}
	
	@Test
	def void testIncompTempOpIntvPoint2() {
		val model = '''
comp c : sv (
	A,B
synchronize:
	A -> A equals start(B)
)
		'''.parse;
		model.assertError(GhostPackage.Literals.EXPRESSION,
			GhostValidator.TEMPOP_INCOMPATIBLE);
	}
	
	@Test
	def void testIncompTempOpIntvPoint3() {
		val model = '''
comp c : sv (
	A,B
synchronize:
	A -> A meets start(B)
)
		'''.parse;
		model.assertError(GhostPackage.Literals.EXPRESSION,
			GhostValidator.TEMPOP_INCOMPATIBLE);
	}
	
	@Test
	def void testIncompTempOpIntvPoint4() {
		val model = '''
comp c : sv (
	A,B
synchronize:
	A -> A |= start(B)
)
		'''.parse;
		model.assertError(GhostPackage.Literals.EXPRESSION,
			GhostValidator.TEMPOP_INCOMPATIBLE);
	}
	
	@Test
	def void testIncompTempOpIntvPoint5() {
		val model = '''
comp c : sv (
	A,B
synchronize:
	A -> A during start(B)
)
		'''.parse;
		model.assertError(GhostPackage.Literals.EXPRESSION,
			GhostValidator.TEMPOP_INCOMPATIBLE);
	}
	
	@Test
	def void testIncompTempOpPointIntv1() {
		val model = '''
comp c : sv (
	A,B
synchronize:
	A -> start(A) = B
)
		'''.parse;
		model.assertError(GhostPackage.Literals.EXPRESSION,
			GhostValidator.TEMPOP_INCOMPATIBLE);
	}
	
	@Test
	def void testIncompTempOpPointIntv2() {
		val model = '''
comp c : sv (
	A,B
synchronize:
	A -> start(A) equals B
)
		'''.parse;
		model.assertError(GhostPackage.Literals.EXPRESSION,
			GhostValidator.TEMPOP_INCOMPATIBLE);
	}
	
	@Test
	def void testIncompTempOpPointIntv3() {
		val model = '''
comp c : sv (
	A,B
synchronize:
	A -> start(A) meets B
)
		'''.parse;
		model.assertError(GhostPackage.Literals.EXPRESSION,
			GhostValidator.TEMPOP_INCOMPATIBLE);
	}
	
	@Test
	def void testIncompTempOpPointIntv4() {
		val model = '''
comp c : sv (
	A,B
synchronize:
	A -> start(A) |= B
)
		'''.parse;
		model.assertError(GhostPackage.Literals.EXPRESSION,
			GhostValidator.TEMPOP_INCOMPATIBLE);
	}
	
	@Test
	def void testIncompTempOpPointIntv5() {
		val model = '''
comp c : sv (
	A,B
synchronize:
	A -> start(A) contains B
)
		'''.parse;
		model.assertError(GhostPackage.Literals.EXPRESSION,
			GhostValidator.TEMPOP_INCOMPATIBLE);
	}
	
	@Test
	def void testIncompTempOp4() {
		val model = '''
comp c : sv (
	A
synchronize:
	A -> meets start(A)
)
		'''.parse;
		model.assertError(GhostPackage.Literals.EXPRESSION,
			GhostValidator.TEMPOP_INCOMPATIBLE);
	}
	
	@Test
	def void testIncompTempOpNoErr() {
		val model = '''
comp c : sv (
	A
synchronize:
	A -> A meets A
)
		'''.parse;
		model.assertNoErrors();
	}
	
	@Test
	def void testInitVarWrongType1() {
		val model = '''
type E = enum (A);
init( var horizon = A; )
		'''.parse;
		model.assertError(GhostPackage.Literals.LOC_VAR_DECL,
			GhostValidator.INIT_VAR_NOT_NUMBER);
	}
	
	@Test
	def void testInitVarNotConst1() {
		val model = '''
init( var x = _; var horizon = x; )
		'''.parse;
		model.assertError(GhostPackage.Literals.QUALIF_INST_VAL,
			GhostValidator.INIT_VAR_NOT_CONSTANT);
	}
	
	@Test
	def void testInitVarNotConst2() {
		val model = '''
init( var x = 12; var horizon = x; )
		'''.parse;
		model.assertError(GhostPackage.Literals.QUALIF_INST_VAL,
			GhostValidator.INIT_VAR_NOT_CONSTANT);
	}
	
	@Test
	def void testInitVarOK() {
		val model = '''
init( var horizon = 20; )
		'''.parse;
		model.assertNoErrors;
	}
	
	@Test
	def void testInitVarConstOK() {
		val model = '''
const HORIZON = 50;
init( var horizon = HORIZON; )
		'''.parse;
		model.assertNoErrors;
	}
	
	@Test
	def void testNoInitVar() {
		val model = '''
type E = enum (A);
type T = sv(C ->  var horizon = A;
)
		'''.parse;
		model.assertNoErrors;
	}
	
	
}
