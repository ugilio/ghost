/*
 * generated by Xtext 2.12.0
 */
package it.cnr.istc.ghost.tests

import com.google.inject.Inject
import it.cnr.istc.ghost.ghost.Expression
import it.cnr.istc.ghost.ghost.Ghost
import it.cnr.istc.ghost.ghost.InheritedKwd
import it.cnr.istc.ghost.ghost.LocVarDecl
import it.cnr.istc.ghost.ghost.QualifInstVal
import it.cnr.istc.ghost.ghost.SyncBody
import it.cnr.istc.ghost.ghost.TransConstrBody
import it.cnr.istc.ghost.validation.AbstractExpressionValidator.ResultType
import it.cnr.istc.ghost.validation.ExpressionValidator
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.XtextRunner
import org.eclipse.xtext.testing.util.ParseHelper
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith

import static org.hamcrest.CoreMatchers.*
import static org.junit.Assert.*
import org.eclipse.xtext.testing.validation.ValidationTestHelper

@RunWith(XtextRunner)
@InjectWith(GhostInjectorProvider)
class GhostExpressionValidatorTest1{

	@Inject extension ParseHelper<Ghost>
	@Inject extension ValidationTestHelper
	
	private static class ExprValidatorAccessor extends ExpressionValidator {
		new() {
			super([],[])
	}
		public def ResultType eval(EObject obj) {
			return super.eval(obj);
		}
	}
	
	private ExprValidatorAccessor v;
	
	@Before
	def void setup() {
		v = new ExprValidatorAccessor();
	}
	
	@Test
	def void testSimpleNum() {
		val model = '''
comp c : sv (
	A -> 1;
)
		'''.parse;
		val body = EcoreUtil2.eAllOfType(model,TransConstrBody).head;
		val exp = EcoreUtil2.eAllOfType(body,Expression).head;
		v.checkExpressions(body);
		val rt = v.eval(exp);
		assertThat(rt,is(ResultType.NUMERIC));
		model.assertNoIssues;
	}
	
	@Test
	def void testSimpleEnum() {
		val model = '''
type e = enum(EN1,EN2);
comp c : sv (
	A -> EN1;
)
		'''.parse;
		val body = EcoreUtil2.eAllOfType(model,TransConstrBody).head;
		val exp = EcoreUtil2.eAllOfType(body,Expression).head;
		v.checkExpressions(body);
		val rt = v.eval(exp);
		assertThat(rt,is(ResultType.ENUM));
		model.assertNoIssues;
	}
	
	@Test
	def void testPlaceholder() {
		val model = '''
comp c : sv(
	A
synchronize:
	A -> _;
)
		'''.parse;
		val body = EcoreUtil2.eAllOfType(model,SyncBody).head;
		val exp = EcoreUtil2.eAllOfType(body,Expression).head;
		v.checkExpressions(body);
		val rt = v.eval(exp);
		assertThat(rt,is(ResultType.UNKNOWN));
		model.assertNoIssues;
	}
	
	@Test
	def void testInstVal1() {
		val model = '''
comp c : sv (
	A -> B; B
)
		'''.parse;
		val body = EcoreUtil2.eAllOfType(model,TransConstrBody).head;
		val exp = EcoreUtil2.eAllOfType(body,Expression).head;
		v.checkExpressions(body);
		val rt = v.eval(exp);
		assertThat(rt,is(ResultType.INSTVAL));
		model.assertNoIssues;
	}
	
	@Test
	def void testInstVal2() {
		val model = '''
type t = int [0,100];
comp c : sv (
	A, B(t x)
synchronize:
	A -> B(10);
)
		'''.parse;
		val body = EcoreUtil2.eAllOfType(model,SyncBody).head;
		val exp = EcoreUtil2.eAllOfType(body,Expression).head;
		v.checkExpressions(body);
		val rt = v.eval(exp);
		assertThat(rt,is(ResultType.INSTVAL));
		model.assertNoIssues;
	}
	
	@Test
	def void testInstVal3() {
		val model = '''
type t = int [0,100];
comp c : sv (
	A, B(t x)
synchronize:
	A -> c.B(10);
)
		'''.parse;
		val body = EcoreUtil2.eAllOfType(model,SyncBody).head;
		val exp = EcoreUtil2.eAllOfType(body,Expression).head;
		v.checkExpressions(body);
		val rt = v.eval(exp);
		assertThat(rt,is(ResultType.INSTVAL));
		model.assertNoIssues;
	}

	@Test
	def void testNamedPar1() {
		val model = '''
type t = int [0,100];
comp c : sv (
	A(t x), B
synchronize:
	A(x) -> x;
)
		'''.parse;
		val body = EcoreUtil2.eAllOfType(model,SyncBody).head;
		val exp = EcoreUtil2.eAllOfType(body,Expression).head;
		v.checkExpressions(body);
		val rt = v.eval(exp);
		assertThat(rt,is(ResultType.NUMERIC));
		model.assertNoIssues;
	}
	
	@Test
	def void testNamedPar2() {
		val model = '''
type e = enum(EN1,EN2);
comp c : sv (
	A(e x), B
synchronize:
	A(x) -> x;
)
		'''.parse;
		val body = EcoreUtil2.eAllOfType(model,SyncBody).head;
		val exp = EcoreUtil2.eAllOfType(body,Expression).head;
		v.checkExpressions(body);
		val rt = v.eval(exp);
		assertThat(rt,is(ResultType.ENUM));
		model.assertNoIssues;
	}	
		
	@Test
	def void testNamedPar3() {
		val model = '''
comp c : resource(10
synchronize:
	require(x) -> x
)
		'''.parse;
		val body = EcoreUtil2.eAllOfType(model,SyncBody).head;
		val exp = EcoreUtil2.eAllOfType(body,Expression).head;
		v.checkExpressions(body);
		val rt = v.eval(exp);
		assertThat(rt,is(ResultType.NUMERIC));
		model.assertNoIssues;
	}
	
	@Test
	def void testFormalPar1() {
		val model = '''
type t = int [0, 100];
comp c : sv (
	A(t x) -> x
)
		'''.parse;
		val body = EcoreUtil2.eAllOfType(model,TransConstrBody).head;
		val exp = EcoreUtil2.eAllOfType(body,Expression).head;
		v.checkExpressions(body);
		val rt = v.eval(exp);
		assertThat(rt,is(ResultType.NUMERIC));
		model.assertNoIssues;
	}	
		
	@Test
	def void testFormalPar2() {
		val model = '''
type e = enum (EN1, EN2);
comp c : sv (
	A(e x) -> x
)
		'''.parse;
		val body = EcoreUtil2.eAllOfType(model,TransConstrBody).head;
		val exp = EcoreUtil2.eAllOfType(body,Expression).head;
		v.checkExpressions(body);
		val rt = v.eval(exp);
		assertThat(rt,is(ResultType.ENUM));
		model.assertNoIssues;
	}	

	@Test
	def void testTimePoint() {
		val model = '''
comp c : sv (
	A, B
synchronize:
	A -> start(B)
)
		'''.parse;
		val body = EcoreUtil2.eAllOfType(model,SyncBody).head;
		val exp = EcoreUtil2.eAllOfType(body,Expression).head;
		v.checkExpressions(body);
		val rt = v.eval(exp);
		assertThat(rt,is(ResultType.INSTVAL));
		model.assertNoIssues;
	}	
		
	@Test
	def void testResConstr() {
		val model = '''
comp r : resource(20);
comp c : sv (
	A
synchronize:
	A -> require r(10);
)
		'''.parse;
		val body = EcoreUtil2.eAllOfType(model,SyncBody).head;
		val exp = EcoreUtil2.eAllOfType(body,Expression).head;
		v.checkExpressions(body);
		val rt = v.eval(exp);
		assertThat(rt,is(ResultType.INSTVAL));
		model.assertNoIssues;
	}	
		
	@Test
	def void testThis() {
		val model = '''
comp c : sv (
	A
synchronize:
	A -> this
)
		'''.parse;
		val body = EcoreUtil2.eAllOfType(model,SyncBody).head;
		val exp = EcoreUtil2.eAllOfType(body,Expression).head;
		v.checkExpressions(body);
		val rt = v.eval(exp);
		assertThat(rt,is(ResultType.INSTVAL));
		model.assertNoIssues;
	}	
		
	@Test
	def void testInherited() {
		val model = '''
type t = sv(A);
comp c : t(
	A -> inherited
)
		'''.parse;
		val body = EcoreUtil2.eAllOfType(model,TransConstrBody).head;
		val exp = EcoreUtil2.eAllOfType(body,InheritedKwd).head;
		v.checkExpressions(body);
		val rt = v.eval(exp);
		assertThat(rt,is(ResultType.UNKNOWN));
		model.assertNoIssues;
	}	

	@Test
	def void testLocVar1() {
		val model = '''
comp c : sv(
	A -> (var x = 1)
)
		'''.parse;
		val body = EcoreUtil2.eAllOfType(model,TransConstrBody).head;
		val exp = EcoreUtil2.eAllOfType(body,LocVarDecl).head;
		v.checkExpressions(body);
		val rt = v.eval(exp);
		assertThat(rt,is(ResultType.NUMERIC));
		model.assertNoIssues;
	}	

	@Test
	def void testLocVar2() {
		val model = '''
comp c : sv(
	A -> (var x = y; var y = x)
)
		'''.parse;
		val body = EcoreUtil2.eAllOfType(model,TransConstrBody).head;
		val exp = EcoreUtil2.eAllOfType(body,LocVarDecl).head;
		v.checkExpressions(body);
		val rt = v.eval(exp);
		assertThat(rt,is(ResultType.UNKNOWN));
		model.assertNoIssues;
	}	

	@Test
	def void testLocVar3() {
		val model = '''
comp c : sv(
	A -> (var x = y; var y = x + 1)
)
		'''.parse;
		val body = EcoreUtil2.eAllOfType(model,TransConstrBody).head;
		val exp = EcoreUtil2.eAllOfType(body,LocVarDecl).head;
		v.checkExpressions(body);
		val rt = v.eval(exp);
		assertThat(rt,is(ResultType.NUMERIC));
		model.assertNoIssues;
	}	

	@Test
	def void testLocVarRef() {
		val model = '''
comp c : sv(
	A -> (var x = 1; x)
)
		'''.parse;
		val body = EcoreUtil2.eAllOfType(model,TransConstrBody).head;
		val exp = EcoreUtil2.eAllOfType(body,QualifInstVal).head;
		v.checkExpressions(body);
		val rt = v.eval(exp);
		assertThat(rt,is(ResultType.NUMERIC));
		model.assertNoIssues;
	}

	@Test
	def void testTempExp1() {
		val model = '''
comp c : sv(
	A,B
synchronize:
	A -> meets B;
)
		'''.parse;
		val body = EcoreUtil2.eAllOfType(model,SyncBody).head;
		val exp = EcoreUtil2.eAllOfType(body,Expression).head;
		v.checkExpressions(body);
		val rt = v.eval(exp);
		assertThat(rt,is(ResultType.TEMPORALEXP));
		model.assertNoIssues;
	}

	@Test
	def void testTempExp2() {
		val model = '''
comp c : sv(
	A,B
synchronize:
	A -> A meets B;
)
		'''.parse;
		val body = EcoreUtil2.eAllOfType(model,SyncBody).head;
		val exp = EcoreUtil2.eAllOfType(body,Expression).head;
		v.checkExpressions(body);
		val rt = v.eval(exp);
		assertThat(rt,is(ResultType.TEMPORALEXP));
		model.assertNoIssues;
	}

	@Test
	def void testEqExp1() {
		val model = '''
comp c : sv(
	A
synchronize:
	A -> 1 = 1;
)
		'''.parse;
		val body = EcoreUtil2.eAllOfType(model,SyncBody).head;
		val exp = EcoreUtil2.eAllOfType(body,Expression).head;
		v.checkExpressions(body);
		val rt = v.eval(exp);
		assertThat(rt,is(ResultType.BOOLEAN));
		model.assertNoIssues;
	}

	@Test
	def void testEqExp2() {
		val model = '''
comp c : sv(
	A
synchronize:
	A -> 1 != 1;
)
		'''.parse;
		val body = EcoreUtil2.eAllOfType(model,SyncBody).head;
		val exp = EcoreUtil2.eAllOfType(body,Expression).head;
		v.checkExpressions(body);
		val rt = v.eval(exp);
		assertThat(rt,is(ResultType.BOOLEAN));
		model.assertNoIssues;
	}

	@Test
	def void testEqExp3() {
		val model = '''
comp c : sv(
	A
synchronize:
	A -> _ = 1;
)
		'''.parse;
		val body = EcoreUtil2.eAllOfType(model,SyncBody).head;
		val exp = EcoreUtil2.eAllOfType(body,Expression).head;
		v.checkExpressions(body);
		val rt = v.eval(exp);
		assertThat(rt,is(ResultType.BOOLEAN));
		model.assertNoIssues;
	}

	@Test
	def void testTempEqExp1() {
		val model = '''
comp c : sv(
	A,B
synchronize:
	A -> A = B;
)
		'''.parse;
		val body = EcoreUtil2.eAllOfType(model,SyncBody).head;
		val exp = EcoreUtil2.eAllOfType(body,Expression).head;
		v.checkExpressions(body);
		val rt = v.eval(exp);
		assertThat(rt,is(ResultType.TEMPORALEXP));
		model.assertNoIssues;
	}

	@Test
	def void testTempEqExp2() {
		val model = '''
comp c : sv(
	A,B
synchronize:
	A -> A = B;
)
		'''.parse;
		val body = EcoreUtil2.eAllOfType(model,SyncBody).head;
		val exp = EcoreUtil2.eAllOfType(body,Expression).head;
		v.checkExpressions(body);
		val rt = v.eval(exp);
		assertThat(rt,is(ResultType.TEMPORALEXP));
		model.assertNoIssues;
	}
	
	@Test
	def void testTempEqExp3() {
		val model = '''
comp c : sv(
	A,B
synchronize:
	A -> _ = B;
)
		'''.parse;
		val body = EcoreUtil2.eAllOfType(model,SyncBody).head;
		val exp = EcoreUtil2.eAllOfType(body,Expression).head;
		v.checkExpressions(body);
		val rt = v.eval(exp);
		assertThat(rt,is(ResultType.TEMPORALEXP));
		model.assertNoIssues;
	}
	

	@Test
	def void testCompExp1() {
		val model = '''
comp c : sv(
	A
synchronize:
	A -> 1 > 0;
)
		'''.parse;
		val body = EcoreUtil2.eAllOfType(model,SyncBody).head;
		val exp = EcoreUtil2.eAllOfType(body,Expression).head;
		v.checkExpressions(body);
		val rt = v.eval(exp);
		assertThat(rt,is(ResultType.BOOLEAN));
		model.assertNoIssues;
	}

	@Test
	def void testTempCompExp1() {
		val model = '''
comp c : sv(
	A, B
synchronize:
	A -> A > B;
)
		'''.parse;
		val body = EcoreUtil2.eAllOfType(model,SyncBody).head;
		val exp = EcoreUtil2.eAllOfType(body,Expression).head;
		v.checkExpressions(body);
		val rt = v.eval(exp);
		assertThat(rt,is(ResultType.TEMPORALEXP));
		model.assertNoIssues;
	}

	@Test
	def void testSumExp() {
		val model = '''
comp c : sv(
	A
synchronize:
	A -> 1 + 1;
)
		'''.parse;
		val body = EcoreUtil2.eAllOfType(model,SyncBody).head;
		val exp = EcoreUtil2.eAllOfType(body,Expression).head;
		v.checkExpressions(body);
		val rt = v.eval(exp);
		assertThat(rt,is(ResultType.NUMERIC));
		model.assertNoIssues;
	}
	
	@Test
	def void testTerm() {
		val model = '''
comp c : sv(
	A
synchronize:
	A -> 1 * 1;
)
		'''.parse;
		val body = EcoreUtil2.eAllOfType(model,SyncBody).head;
		val exp = EcoreUtil2.eAllOfType(body,Expression).head;
		v.checkExpressions(body);
		val rt = v.eval(exp);
		assertThat(rt,is(ResultType.NUMERIC));
		model.assertNoIssues;
	}
	
	@Test
	def void testComplexExp() {
		val model = '''
type t = int [0,100];
comp c : sv(
	A(t x)
synchronize:
	A(x) -> x + 100* x/2 + 7 =  (12 +7);
)
		'''.parse;
		val body = EcoreUtil2.eAllOfType(model,SyncBody).head;
		val exp = EcoreUtil2.eAllOfType(body,Expression).head;
		v.checkExpressions(body);
		val rt = v.eval(exp);
		assertThat(rt,is(ResultType.BOOLEAN));
		model.assertNoIssues;
	}
	
	@Test
	def void testUndefSymbol() {
		val model = '''
comp c : sv(
	A
synchronize:
	A -> x + 1;
)
		'''.parse;
		val body = EcoreUtil2.eAllOfType(model,SyncBody).head;
		val exp = EcoreUtil2.eAllOfType(body,Expression).head;
		v.checkExpressions(body);
		val rt = v.eval(exp);
		assertThat(rt,is(ResultType.NUMERIC));
	}
	
}
