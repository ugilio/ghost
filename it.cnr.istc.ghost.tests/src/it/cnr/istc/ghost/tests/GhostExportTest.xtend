/*
 * Copyright (c) 2017 Giulio Bernardi (https://github.com/ugilio/).
 * All rights reserved.   This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * generated by Xtext 2.12.0
 */
package it.cnr.istc.ghost.tests

import com.google.inject.Inject
import it.cnr.istc.ghost.ghost.Ghost
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.XtextRunner
import org.eclipse.xtext.testing.util.ParseHelper
import org.junit.Test
import org.junit.runner.RunWith

import static org.junit.Assert.*
import static org.hamcrest.CoreMatchers.*
import org.eclipse.xtext.resource.IResourceServiceProvider
import org.eclipse.xtext.naming.IQualifiedNameConverter
import org.eclipse.emf.ecore.resource.Resource
import java.util.List

@RunWith(XtextRunner)
@InjectWith(GhostInjectorProvider)
class GhostExportTest{

	@Inject
	ParseHelper<Ghost> parseHelper
	
	@Inject IResourceServiceProvider.Registry rspr
	@Inject IQualifiedNameConverter converter
     
    def void printExportedObjects(Resource resource) {
        for (name : getExportedObjects(resource)) {
            println(name)
        }
    }
    
	def List<String> getExportedObjects(Resource resource) {
		val resServiceProvider = rspr.getResourceServiceProvider(resource.URI)
		val manager = resServiceProvider.getResourceDescriptionManager()
		val description = manager.getResourceDescription(resource)
		return description.exportedObjects.map[eod | converter.toString(eod.qualifiedName)].toList;
    }	

	@Test
	def void testDomainExports() {
		val result = parseHelper.parse('''
domain TheDomain;

type ANumType = int [0,100];

type AEnumType = enum (en1, en2, en3);

type ASVType = sv(
	StateA -> StateB;
	StateB(ANumType x, AEnumType y) -> StateA;
synchronize:
	StateB -> ( 
		var a = 12;
		StateA meets StateB;
		var c = start(StateA);
		7 = 12;
		15 ms;
	);
variable:
	avar : ASVType;
);

type AResourceType = resource(19);

type ADescendantResource = resource AResourceType(27);

comp AComponent : ASVType[avar = AComponent];

comp AResource : resource(10,20);

comp ASVWithAnonymousType : sv(
	A(ANumType x) -> B;
	C
synchronize:
	A(x) -> x < 10;
);

const MAX = 100;
const MIN = 0+2;
const END = [0, +INF];

init (fact AComponent.StateA at start=0;);
		''')
		assertNotNull(result)
		val exported = getExportedObjects(result.eResource);
		val expected = '''TheDomain
TheDomain
TheDomain.ANumType
TheDomain.AEnumType
TheDomain.en1
TheDomain.en2
TheDomain.en3
TheDomain.ASVType
TheDomain.ASVType.StateA
TheDomain.ASVType.StateB
TheDomain.ASVType.avar
TheDomain.AResourceType
TheDomain.ADescendantResource
TheDomain.AComponent
TheDomain.AResource
TheDomain.ASVWithAnonymousType
TheDomain.ASVWithAnonymousType.A
TheDomain.ASVWithAnonymousType.C
TheDomain.MAX
TheDomain.MIN
TheDomain.END'''.toString.split("\n").toList;
		assertThat(exported,is(equalTo(expected)));
	}
	
	@Test
	def void testProblemExports() {
		val result = parseHelper.parse('''
problem TheProblem;

type ANumType = int [0,100];

type AEnumType = enum (en1, en2, en3);

type ASVType = sv(
	StateA -> StateB;
	StateB(ANumType x, AEnumType y) -> StateA;
synchronize:
	StateB -> ( 
		var a = 12;
		var b = StateA meets StateB;
		var c = start(StateA);
		7 = 12;
		15 ms;
	);
variable:
	avar : ASVType;
);

type AResourceType = resource(19);

type ADescendantResource = resource AResourceType(27);

comp AComponent : ASVType[avar = AComponent];

comp AResource : resource(10,20);

comp ASVWithAnonymousType : sv(
	A(ANumType x) -> B;
	C
synchronize:
	A(x) -> x < 10;
);

const MAX = 100;
const MIN = 0+2;
const END = [0, +INF];

init (fact AComponent.StateA at start=0;);
		''')
		assertNotNull(result)
		val exported = getExportedObjects(result.eResource);
		assertThat(exported,is(equalTo(emptyList)));
	}
	
	@Test
	def void testUnnamedExports() {
		val result = parseHelper.parse('''
type ANumType = int [0,100];

type AEnumType = enum (en1, en2, en3);

type ASVType = sv(
	StateA -> StateB;
	StateB(ANumType x, AEnumType y) -> StateA;
synchronize:
	StateB -> ( 
		var a = 12;
		var b = StateA meets StateB;
		var c = start(StateA);
		7 = 12;
		15 ms;
	);
variable:
	avar : ASVType;
);

type AResourceType = resource(19);

type ADescendantResource = resource AResourceType(27);

comp AComponent : ASVType[avar = AComponent];

comp AResource : resource(10,20);

comp ASVWithAnonymousType : sv(
	A(ANumType x) -> B;
	C
synchronize:
	A(x) -> x < 10;
);

const MAX = 100;
const MIN = 0+2;
const END = [0, +INF];

init (fact AComponent.StateA at start=0;);
		''')
		assertNotNull(result)
		val exported = getExportedObjects(result.eResource);
		assertThat(exported,is(equalTo(emptyList)));
	}
}
