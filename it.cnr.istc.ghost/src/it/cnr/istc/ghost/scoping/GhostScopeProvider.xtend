/*
 * generated by Xtext 2.12.0
 */
package it.cnr.istc.ghost.scoping

import org.eclipse.xtext.scoping.IScope
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import it.cnr.istc.ghost.ghost.GhostPackage
import it.cnr.istc.ghost.ghost.NamedCompDecl
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.xtext.EcoreUtil2
import it.cnr.istc.ghost.ghost.ComponentType
import it.cnr.istc.ghost.ghost.ObjVarDecl
import it.cnr.istc.ghost.ghost.QualifInstVal
import it.cnr.istc.ghost.ghost.ValueDecl
import it.cnr.istc.ghost.ghost.SyncBody
import it.cnr.istc.ghost.ghost.Synchronization
import it.cnr.istc.ghost.ghost.NamedPar
import java.util.Collections
import it.cnr.istc.ghost.ghost.LocVarDecl
import com.google.common.collect.Iterables
import it.cnr.istc.ghost.ghost.TransConstrBody
import it.cnr.istc.ghost.ghost.TransConstraint
import it.cnr.istc.ghost.ghost.FormalPar
import it.cnr.istc.ghost.ghost.SimpleInstVal
import it.cnr.istc.ghost.ghost.SvDecl

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class GhostScopeProvider extends AbstractGhostScopeProvider {
	
	private def getScopeFor(ComponentType type) {
		if (type === null)
			return IScope.NULLSCOPE;
		return Scopes.scopeFor(EcoreUtil2.eAllOfType(type,ValueDecl));
	}
	
	private def getScopeForBlock(EObject context, IScope parent) {
		//Inside a synchronization body
		val syncbody = EcoreUtil2.getContainerOfType(context,SyncBody);
		if (syncbody !== null) {
			val trigger = (syncbody.eContainer as Synchronization).trigger;
			val args = if (trigger !== null) EcoreUtil2.eAllOfType(trigger,NamedPar)
						else Collections.emptyList;
			val locVars = EcoreUtil2.eAllOfType(syncbody,LocVarDecl);
			return Scopes.scopeFor(Iterables.concat(args,locVars),parent);
		}
		//Inside a transition constraint body
		val tcbody = EcoreUtil2.getContainerOfType(context,TransConstrBody);
		if (tcbody !== null) {
			val head = (tcbody.eContainer as TransConstraint).head;
			val args = if (head !== null) EcoreUtil2.eAllOfType(head,FormalPar)
						else Collections.emptyList;
			val locVars = EcoreUtil2.eAllOfType(tcbody,LocVarDecl);
			return Scopes.scopeFor(Iterables.concat(args,locVars),parent);
		}
		return parent;
	}
	
	/**
	 * Returns nested scopes for each parent. This way most recent ancestors
	 * are searched first
	 */
	private def IScope getScopeForSyncTrigger(EObject v) {
		if (v === null)
			return IScope.NULLSCOPE;
		val comp = EcoreUtil2.getContainerOfType(v,NamedCompDecl);
		if (comp !== null)
			return Scopes.scopeFor(EcoreUtil2.eAllOfType(comp,ValueDecl),
				getScopeForSyncTrigger(comp.type));
		val type = EcoreUtil2.getContainerOfType(v,SvDecl);
		if (type !== null)
			return Scopes.scopeFor(EcoreUtil2.eAllOfType(type,ValueDecl),
				getScopeForSyncTrigger(type.parent));

		return IScope.NULLSCOPE;
	}
	
	override IScope getScope(EObject context, EReference reference) {
		
		if (context instanceof QualifInstVal &&
			reference == GhostPackage.Literals.QUALIF_INST_VAL__VALUE) {
				val comp = (context as QualifInstVal).comp;
				if (comp === null) {
					return getScopeForBlock(context,super.getScope(context,reference));
				}
				//component.value: scope is the values defined in component
				else switch (comp) {
					NamedCompDecl : return getScopeFor(comp.type)
					ObjVarDecl : return getScopeFor(comp.type)
				}
		}
		//Synchronization triggers
		if (context instanceof SimpleInstVal &&
			reference == GhostPackage.Literals.SIMPLE_INST_VAL__VALUE)
		{
			val scope = getScopeForSyncTrigger(context);
			if (scope !== IScope.NULLSCOPE)
				return scope;
		}

		return super.getScope(context, reference);
	}
	

}
