/*
 * generated by Xtext 2.12.0
 */
package it.cnr.istc.ghost.validation

import static it.cnr.istc.ghost.ghost.GhostPackage.Literals.*;

import org.eclipse.xtext.validation.Check
import it.cnr.istc.ghost.ghost.SvDecl
import java.util.HashSet
import it.cnr.istc.ghost.ghost.ResourceDecl
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import it.cnr.istc.ghost.ghost.EnumDecl
import java.util.List
import org.eclipse.emf.ecore.EStructuralFeature
import it.cnr.istc.ghost.ghost.Ghost
import it.cnr.istc.ghost.naming.GhostNameProvider
import it.cnr.istc.ghost.ghost.ResSimpleInstVal
import org.eclipse.xtext.EcoreUtil2
import it.cnr.istc.ghost.ghost.ResourceBody
import it.cnr.istc.ghost.ghost.CompResBody
import it.cnr.istc.ghost.ghost.QualifInstVal
import it.cnr.istc.ghost.ghost.ValueDecl
import it.cnr.istc.ghost.ghost.SimpleInstVal
import it.cnr.istc.ghost.ghost.Synchronization

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class GhostValidator extends AbstractGhostValidator {
	
	public static val CYCLIC_HIERARCHY = 'cyclicHierarchy';
	public static val EMPTY_ENUM = 'emptyEnum';
	public static val DUPLICATE_IDENTIFIER = 'duplicateIdentifier';
	public static val DUPLICATE_IMPORT = 'duplicateImport';
	public static val RESACTION_NONRES = 'resactionNonRes';
	public static val SYNCH_INVALID_PARNUM = "synchInvalidParNum";
	public static val QUALIFINSTVAL_INCOMPATIBLE_COMP = "qualifInstValIncompatibleComp";
	public static val QUALIFINSTVAL_INCOMPATIBLE_ARGS = "qualifInstValIncompatibleArgs";

	// Checks for type hierarchy

	private def dispatch EObject getParent(SvDecl decl) {
		return decl.parent;
	}

	private def dispatch EObject getParent(ResourceDecl decl) {
		return decl.parent;
	}
	
	private def dispatch EObject getParent(Object o) {
		return null;
	}
	
	protected def checkHierarcyCycles(EObject decl, EReference feature) {
		val visited = new HashSet<EObject>();
		var tmp = decl;
		visited.add(tmp);
		while (getParent(tmp)!==null) {
			tmp = getParent(tmp);
			if (visited.contains(tmp)) {
				error('Cyclic dependency in type hierarchy', 
						feature,
						it.cnr.istc.ghost.validation.GhostValidator.CYCLIC_HIERARCHY)
				return;
			}
			visited.add(tmp);
		}
	}
		
	@Check
	def checkSVHierarcyCycles(SvDecl decl) {
		checkHierarcyCycles(decl,SV_DECL__PARENT);
	}
	
	@Check
	def checkResHierarcyCycles(ResourceDecl decl) {
		checkHierarcyCycles(decl,RESOURCE_DECL__PARENT);
	}
	
	//Checks for missing values / empty references
	
	@Check
	def checkEnumIsNotEmpty(EnumDecl e) {
		if (e.values.isEmpty())
			error("Enumeration cannot be empty",ENUM_DECL__VALUES,EMPTY_ENUM);
	}
	
	//Checks for duplicate identifiers
	private def getObjName(EObject obj) {
		return GhostNameProvider.getObjName(obj);
	}

	private def getByName(Object name, List<EObject> list) {
		if (name!==null)
			for (o : list)
				if (name.equals(getObjName(o)))
					return o;
		return null;
	} 
	
	private def checkDuplicateIdentifiers(EObject cont, EStructuralFeature feat,
		String msg, String id) {
		val list = cont.eGet(feat) as List<EObject>;
		for (o : list) {
			val name = getObjName(o)
			if (name!==null && getByName(name,list) != o)
				error(String.format(msg,name),feat,list.indexOf(o),id);
		}
	}
	
	@Check
	def checkUniqueTopLevelDeclarations(Ghost ghost) {
		checkDuplicateIdentifiers(ghost,GHOST__DECLS,"Duplicate identifier '%s'",DUPLICATE_IDENTIFIER);
	}
	
	@Check
	def checkUniqueImports(Ghost ghost) {
		checkDuplicateIdentifiers(ghost,GHOST__IMPORTS,"Duplicate import '%s'",DUPLICATE_IMPORT);
	}
	
	@Check
	def checkQualifInstValCompat(QualifInstVal v) {
		if (! (v.value instanceof ValueDecl)) {
			if (v.comp !== null)
				error(String.format("Cannot find value '%s' in '%s'",v.value.name,v.comp.name),
					 QUALIF_INST_VAL__VALUE,QUALIFINSTVAL_INCOMPATIBLE_COMP);
			if (v.arglist !== null)
				error(String.format("'%s' cannot have arguments since it is not a value",v.value.name),
					 QUALIF_INST_VAL__ARGLIST,QUALIFINSTVAL_INCOMPATIBLE_ARGS);
		}
	}
	
	
	//Synchronizations check
	@Check
	def checkResactionTrigger(ResSimpleInstVal v) {
		if (EcoreUtil2.getContainerOfType(v,ResourceBody) !== null)
			return;
		if (EcoreUtil2.getContainerOfType(v,CompResBody) !== null)
			return;
		error("Resource actions can be used as triggers in resources only",RES_SIMPLE_INST_VAL__TYPE,RESACTION_NONRES);
	}
	
	@Check
	def checkSynchArgs(SimpleInstVal v) {
		if (!(v.eContainer instanceof Synchronization))
			return;
		val s = v.eContainer as Synchronization;
		if (s.trigger === v) {
			val formalLen = if (v.value?.parlist?.values !== null) v.value.parlist.values.size
				else 0;
			val actLen = if (v.arglist?.values !== null) v.arglist.values.size
				else 0;
			if (actLen>formalLen)
				error(String.format(
					"Incompatible parameter list: maximum %d parameters expected, got %d",
					formalLen,actLen),SIMPLE_INST_VAL__ARGLIST,SYNCH_INVALID_PARNUM);
		}
	}
	
}
