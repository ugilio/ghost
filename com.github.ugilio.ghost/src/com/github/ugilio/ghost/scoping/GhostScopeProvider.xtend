/*
 * Copyright (c) 2017 Giulio Bernardi (https://github.com/ugilio/).
 * All rights reserved.   This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * generated by Xtext 2.12.0
 */
package com.github.ugilio.ghost.scoping

import com.github.ugilio.ghost.ghost.CompDecl
import com.github.ugilio.ghost.ghost.ComponentType
import com.github.ugilio.ghost.ghost.GhostPackage
import com.github.ugilio.ghost.ghost.NamedCompDecl
import com.github.ugilio.ghost.ghost.ObjVarDecl
import com.github.ugilio.ghost.ghost.QualifInstVal
import com.github.ugilio.ghost.ghost.ResourceDecl
import com.github.ugilio.ghost.ghost.SvDecl
import com.github.ugilio.ghost.ghost.ValueDecl
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import com.github.ugilio.ghost.utils.Utils

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class GhostScopeProvider extends AbstractGhostScopeProvider {
	
	private def dispatch IScope getScopeFor(Void type) {
		return IScope.NULLSCOPE;
	}
	
	private def dispatch IScope getScopeFor(ComponentType type) {
		val parentScope = switch(type) {
			SvDecl : getScopeFor(type.parent)
			ResourceDecl : getScopeFor(type.parent)
			default: IScope.NULLSCOPE
		}
		return Scopes.scopeFor(EcoreUtil2.eAllOfType(type,ValueDecl),parentScope);
	}
	
	private def dispatch IScope getScopeFor(ObjVarDecl decl) {
		return getScopeFor(decl.type);
	}
	
	private def dispatch IScope getScopeFor(CompDecl comp) {
		val parentScope = switch (comp) {
			NamedCompDecl : getScopeFor(comp.type)
			default : IScope.NULLSCOPE
		}
		return Scopes.scopeFor(EcoreUtil2.eAllOfType(comp,ValueDecl),parentScope);
	}
	
	private def getScopeForBlock(EObject context, IScope parent) {
		var EObject cont = EcoreUtil2.getContainerOfType(context,ComponentType);
		if (cont === null)
			cont = EcoreUtil2.getContainerOfType(context,CompDecl);
		val compScope = new CompositeScope(getScopeFor(cont),parent);
		val itr = Utils.getSymbolsForBlock(context);
		return if (itr === null) compScope else return Scopes.scopeFor(itr,compScope);
	}
	
	/**
	 * Returns nested scopes for each parent. This way most recent ancestors
	 * are searched first
	 */
	private def IScope getScopeForSyncTrigger(EObject v) {
		if (v === null)
			return IScope.NULLSCOPE;
		val comp = EcoreUtil2.getContainerOfType(v,NamedCompDecl);
		if (comp !== null)
			return Scopes.scopeFor(EcoreUtil2.eAllOfType(comp,ValueDecl),
				getScopeForSyncTrigger(comp.type));
		val type = EcoreUtil2.getContainerOfType(v,SvDecl);
		if (type !== null)
			return Scopes.scopeFor(EcoreUtil2.eAllOfType(type,ValueDecl),
				getScopeForSyncTrigger(type.parent));

		return IScope.NULLSCOPE;
	}
	
	private def IScope getScopeForBindName(EObject v) {
		if (v === null)
			return IScope.NULLSCOPE;
		val comp = EcoreUtil2.getContainerOfType(v,CompDecl);
		if (comp !== null) {
			val pScope = if (comp instanceof NamedCompDecl)
					getScopeForBindName(comp.type)
				else
					IScope.NULLSCOPE;
			return Scopes.scopeFor(EcoreUtil2.eAllOfType(comp,ObjVarDecl),pScope);
		}
		val type = EcoreUtil2.getContainerOfType(v,ComponentType);
		if (type !== null) {
			val pScope = switch(type)
				{
					SvDecl: getScopeForBindName(type.parent)
					ResourceDecl: getScopeForBindName(type.parent)
					default: IScope.NULLSCOPE
				}
			return Scopes.scopeFor(EcoreUtil2.eAllOfType(type,ObjVarDecl),pScope);
		}

		return IScope.NULLSCOPE;
	}	
	
	override IScope getScope(EObject context, EReference reference) {
		
		if (reference == GhostPackage.Literals.QUALIF_INST_VAL__COMP) {
				return new CompositeScope(
					getScopeForBindName(context),super.getScope(context,reference));
		}
		if (reference == GhostPackage.Literals.RES_CONSTR__RES) {
				return new CompositeScope(
					getScopeForBindName(context),super.getScope(context,reference));
		}
		if (context instanceof QualifInstVal &&
			reference == GhostPackage.Literals.QUALIF_INST_VAL__VALUE) {
				val comp = (context as QualifInstVal).comp;
				if (comp !== null && !comp.eIsProxy()) {
				//component.value: scope is the values defined in component
					return getScopeFor(comp);
				}
		}
		if (reference == GhostPackage.Literals.QUALIF_INST_VAL__VALUE) {
			return getScopeForBlock(context,super.getScope(context,reference));
		}
		//Synchronization triggers
		if (reference == GhostPackage.Literals.SIMPLE_INST_VAL__VALUE)
		{
			val scope = getScopeForSyncTrigger(context);
			if (scope !== IScope.NULLSCOPE)
				return scope;
		}
		if (reference == GhostPackage.Literals.BIND_PAR__NAME)
		{
			val scope = getScopeForBindName(context);
			if (scope !== IScope.NULLSCOPE)
				return scope;
		}

		return super.getScope(context, reference);
	}
	

}
